<template>

    <div class="page no-tabbar" data-name="cart">
        <!-- Navbar remains unchanged -->
        <div id="conversation-navbar" class="navbar">
            <div class="navbar-bg"></div>
            <div class="navbar-inner">
                <div class="left">
                    <a href="#" class="link back">
                        <i class="icon icon-back"></i>
                        <span class="if-not-md">Back</span>
                    </a>
                </div>
                <div class="title">${chat.title}</div>
                <div class="right">
                    <a href="#" data-tooltip="Reproducir conversación" class="link tooltip-init icon-only"><i
                            class="icon material-icons">play</i></a>
                    <a href="/screens/conversation" data-tooltip="New conversation"
                       class="link tooltip-init icon-only"><i class="icon material-icons">add</i></a>

                    <a href="#" data-tooltip="Configuration" class="link tooltip-init icon-only"
                       @click="${openPopupConfig}">
                        <i class="icon material-icons">settings</i>
                    </a>
                    ${assistant ? $h`
                    <a href="#" class="link icon-only popover-open tooltip-init" data-popover="#popover-assistants"
                       data-tooltip="Change Assistant">
                        <img class="shape-circle" width="40" src="${assistant.avatar}"/>

                    </a>
                    ` : ''}
                </div>
            </div>
        </div>

        <div class="toolbar messagebar messagebar-chat" style="${showBottomBar ? '' : 'display:none'}">
            <div id="page-toolbar" class="toolbar-inner" style="min-height: 70px;">

            </div>
        </div>
        <!-- Page content with messages and messagebar inside -->
        <div class="page-content" id="conversationPage">
            <div class="row justify-content-center no-gap padding-horizontal-half"
                 style="--f7-card-margin-horizontal: 8px;">
                <div id="message-area" class="col-100 medium-65 margin-bottom-half margin-top large-70 xlarge-65">
                    <div style=""
                         class="messages-content justify-content-center padding-top row">
                        <div class="col-90 large-60 medium-75 messages xlarge-70" id="messages-space">

                        </div>
                        <!-- Centered messagebar component (only show when no messages) -->

                        <div id="prompt-area"
                             class="centered-messagebar-container">
                            ${!showBottomBar ? $h`
                            <div class="display-flex justify-content-center width-100">
                                <img src="${assistant ? assistant.mainImage : ''}" width="300" class=""/>
                            </div>

                            <div class="block-title-large margin text-align-center">
                                ${myDevice ?
                                (assistant ? assistant.greeting : '') :
                                (chat && chat.mainAssistant && chat.mainAssistant.deviceSelector ?
                                'Please select a device.' :
                                (assistant ? assistant.greeting : ''))}
                            </div>
                            <!-- Remaining components unchanged -->

                            ` : ''}
                            <div id="messagebar-chat"
                                 style=""
                                 class="messagebar-chat centered-messagebar auto-height">

                            <div class="messagebar-inner">
                                <div class="messagebar-area" style="overflow:visible; width: 100%;">
                                    <div class="file-dropzone invisible" id="file-dropzone">
                                        <input type="file" id="file-upload" multiple class="file-upload-input"
                                               style="display:none;"/>
                                    </div>
                                    <textarea
                                            style="${(chat && chat.mainAssistant && chat.mainAssistant.deviceSelector) ? (myDevice ? '' : 'display:none') : ''}"
                                            id="prompt"
                                            placeholder="${(chat && chat.mainAssistant && chat.mainAssistant.deviceSelector && !myDevice) ? 'Ask anything about one particular device (please select a device first)...' : (assistant ? assistant.placeholder : '')}"
                                            @input="${handlePromptTextArea}"
                                            @keydown="${handleKeyDown}"
                                            class="input-with-value resizable keyboard-mode">
                                    </textarea>
                                    <div id="assistants-suggestions" class="assistants-suggestions"
                                         style="display: none;">
                                        <div class="assistants-suggestions-title">Available Assistants</div>
                                        <div class="assistants-suggestions-list"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="messagebar-buttons-bottom">
                                <div class="row align-items-center">
                                    <div class="col-90">
                                        <div id="device-list"
                                             class="block float-left margin-bottom-auto margin-horizontal-auto inset margin-vertical"
                                             style="">

                                            ${(myDevice || (chat && chat.mainAssistant &&
                                            chat.mainAssistant.deviceSelector === false)) ? $h`
                                            ${chat && chat.mainAssistant && chat.mainAssistant.deviceSelector ? $h`
                                            <div data-tooltip="Select other device"
                                                 class="tooltip-init bg-color-blue chip cursor-pointer"
                                                 @click="${handleOpenDeviceSelection}">
                                                <div class="chip-label">${myDevice}</div>
                                            </div>
                                            ` : ''}



                                            <a href="#" @click="${handleFileUploadClick}"
                                               style="height: 35px!important;" data-tooltip="Upload a document"
                                               class="tooltip-init link button-outline float-left margin-right-half button border-color-chrome button-icon button-round color-gray"><i
                                                    class="fa fa-paperclip"></i></a>

                                            ${chat && chat.noSelectionInstructions &&
                                            chat.noSelectionInstructions.length > 0 ? $h`
                                            <div data-tooltip="Open toolbox"
                                                 class="tooltip-init bg-color-bluegray chip cursor-pointer"
                                                 @click="${() => actionsCustomLayout.open()}">
                                                <div class="chip-media">
                                                    <i class="fa fa-tools fa-icon"></i>
                                                </div>
                                                <div class="chip-label">${chat.noSelectionInstructions.length} shortcuts
                                                </div>
                                            </div>
                                            ` : ''}

                                            ` : $h`
                                            `}
                                            ${chat && chat.mainAssistant && chat.mainAssistant.deviceSelector ?
                                            devices.map((device, index) => $h`
                                            <label style="${myDevice ? 'display:none' : ''}" class="chip-selectable">
                                                ${myDevice === device ? $h`
                                                <input type="radio" @change="${handleDeviceSelection}"
                                                       name="chip-selectable-device" checked="checked"
                                                       value="${device}"/>
                                                ` : $h`
                                                <input type="radio" @change="${handleDeviceSelection}"
                                                       name="chip-selectable-device" value="${device}"/>
                                                `}
                                                <div class="chip">
                                                    <div class="chip-label">${device}</div>
                                                </div>
                                            </label>
                                            `)
                                            : ''}
                                            ${Object.keys(highlights).length > 0 ? $h`
                                            <a href="#" @click="${showHighlights}"
                                               style="height: 35px!important;"
                                               data-tooltip="Review selected text"
                                               class="tooltip-init link button-outline float-left margin-right-half button border-color-chrome button-icon button-round color-gray">
                                                <i class="fa fa-highlighter" style="color:yellow!important"></i>
                                            </a>
                                            ` : ''}
                                        </div>
                                    </div>
                                    <div class="col-10 display-flex justify-content-right align-items-center">
                                        ${isResponding ? $h`
                                        <a href="#" @click="${stopStreaming}" style=""
                                           data-tooltip=''
                                           class="link tooltip-init margin-right float-right message-bar-icon ripple-color-gray">
                                            <i class="fa fa-2x fa-stop-circle fa-icon" style="color: #FF5252;"></i>
                                        </a>
                                        ` : ((!prompt || !myDevice) && (chat && chat.mainAssistant &&
                                        chat.mainAssistant.deviceSelector)) ? $h`
                                        <a href="#" @click="${sendPrompt}" style=""
                                           data-tooltip='Send message'
                                           class="disabled link tooltip-init margin-right float-right message-bar-icon ripple-color-gray">
                                            <i class="fa fa-2x fa-arrow-circle-up fa-icon" style="color: #ffffff;"></i>
                                        </a>
                                        ` : $h`
                                        <a href="#" @click="${sendPrompt}" style=""
                                           data-tooltip='Send message'
                                           class="link tooltip-init margin-right float-right message-bar-icon ripple-color-gray">
                                            <i class="fa fa-2x fa-arrow-circle-up fa-icon" style="color: #4CAF50;"></i>
                                        </a>
                                        `}
                                    </div>
                                </div>
                            </div>
                        </div>

                        ${quick_actions && quick_actions.length > 0 && !showBottomBar ? $h`
                        <div class="quick-actions-container no-margin-top text-align-center"
                             style="max-width:650px!important">
                            <div class="block float-left">
                                ${quick_actions.map((action, index) => $h`
                                <div data-tooltip="${action.description}"
                                     style="background-color:${action.color} "
                                     class="quick-action-chip link chip-outline tooltip-init padding chip cursor-pointer"
                                     @click="${() => {
                 // Primero crear la conversación
                 quick_actions = [];
                 createConversation(assistant.guid).then(() => {
                     // Luego ejecutar el código de la acción
                     if (action.code) {
                         eval(action.code);
                     }
                 });
             }}">
                                    <div style="color:white" class="chip-media">
                                        <i class="fa ${action.icon || 'fa-bolt'} fa-icon"
                                           style="color:${action.color}"></i>
                                    </div>
                                    <div class="font-size-16 chip-label">${action.shortTitle}</div>
                                </div>
                                `)}
                            </div>
                        </div>
                        ` : ''}
                        <div id="legal-info" class="margin-bottom-half legal-info text-align-center">SIMBA may make mistakes. Consider verifying
                            important information. See the <a href="/screens/terms/" class="link">disclaimer</a> for
                            details.
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="scrollToBottom" @click="${scrollToBottom}"
             class="fab fab-center-bottom hidden color-gray opacity-75">
            <a href="#">
                <i class="fa fa-arrow-down"></i>
            </a>
        </div>
        <div class="block-footer"></div>
    </div>

    <!-- Fixed bottom messagebar (only show when there are messages) -->
    <!-- Fixed bottom messagebar (only show when there are messages) -->


    <div id="dialog-choice-chip" class="dialog">
        <div class="dialog-inner">
            <div class="dialog-title">Choose te reason for your feedback</div>
            <form name="dialog-choice-chip" action="#" method="POST" enctype="multipart/form-data"
                  @submit="${(event) => event.preventDefault()}">
                <div class="block margin-top no-margin-bottom no-padding-horizontal">
                    ${unlikeReasons.map((option, index) => $h`
                    <label data-tooltip="${option.description}" class="tooltip-init chip-selectable">
                        <input type="checkbox" name="interests" value="${option.value}"/>
                        <div class="chip color-pink">
                            <div class="chip-label">${option.reason}</div>
                        </div>
                    </label>
                    `)}
                    <textarea class="padding margin" style="width:90%;height:200px;background-color:#333333!important"
                              placeholder="Please describe your feedback"></textarea>

                </div>
            </form>
        </div>
        <div class="dialog-buttons">
            <span class="dialog-button color-gray" @click="${closeDialogChoiceChip}">Cancel</span>
            <span class="dialog-button" @click="${submitFormDialogChoiceChip}">OK</span>
        </div>
    </div>


    <div id="popup-ticket" class="popup">
        <div class="page">
            <div class="navbar">
                <div class="navbar-bg"></div>
                <div class="navbar-inner">
                    <div class="title">Confirm Support Ticket</div>
                    <div class="right">
                        <a class="link icon-only" @click="${() => closePopupTicket(false)}">
                            <i class="icon material-icons">cancel</i>
                        </a>
                    </div>
                </div>
            </div>

            <div class="page-content">

                <div class="block block-strong inset margin-vertical">
                    <div class="margin-top text-align-center">
                        <div class="font-size-24 font-weight-bold">Confirm Support Ticket</div>
                        <div class="font-size-16 margin-top-half text-color-gray">Please confirm the details of your
                            support request.
                        </div>
                    </div>
                </div>
                <form name="ticket" action="#" method="POST" enctype="multipart/form-data">
                    <div class="list inset margin-vertical">
                        <ul class="padding-vertical-half">
                            <li>
                                <div class="item-content item-input item-input-outline">
                                    <div class="item-inner">
                                        <div class="item-input-wrap">
                                            <div class="item-media">
                                                <i class="icon material-icons">devices</i>
                                            </div>
                                            <input type="text" value="${ticket.device}" name="device"
                                                   placeholder="Device" required/>
                                            <span class="input-clear-button"></span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li>
                                <div class="item-content item-input item-input-outline">
                                    <div class="item-inner">
                                        <div class="item-input-wrap">
                                            <div class="item-media">
                                                <i class="icon material-icons">title</i>
                                            </div>
                                            <input type="text" name="problem_title" value="${ticket.problem_title}"
                                                   placeholder="Title" required/>
                                            <span class="input-clear-button"></span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li>
                                <div class="item-content item-input item-input-outline">
                                    <div class="item-inner">
                                        <div class="item-input-wrap">
                                            <div class="item-media align-self-flex-start">
                                                <i class="icon material-icons">description</i>
                                            </div>
                                            <textarea name="problem_description" class="resizable"
                                                      placeholder="Description" required style="min-height: 128px;">${ticket.problem_description}</textarea>
                                            <span class="input-clear-button"></span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li>
                                <div class="item-content">
                                    <div class="item-inner">
                                        <button type="submit" class="button button-fill button-large">Confirm Ticket
                                        </button>
                                    </div>
                                </div>
                            </li>
                        </ul>
                    </div>
                </form>
            </div>

        </div>
    </div>
    <div id="actions-custom-layout" class="actions-modal">
        <div class="actions-group text-align-center">
            <a href="#" class="link shape-container shape-circle overflow-hidden ripple-color-gray"
               style="background-color: var(--f7-list-bg-color);" @click="${() => actionsCustomLayout.close()}">
                <i class="icon material-icons text-color-mono">close</i>
            </a>
        </div>
        <div class="actions-group">
            <div class="list media-list inset no-chevron no-hairlines-between no-margin">
                <ul>

                    ${chat.instructions.map((option, index) => option.isSelection === 0 ? $h`
                    <li>
                        <a href="#" class="item-link" @click="${(e) => {
                e.preventDefault();

                if (option.code !== null && option.code !== undefined) {
                   eval(option.code);
                } else {
                 setPrompt(option.prompt);
                }
            }}">
                            <div class="item-content">
                                <div class="item-media">
<span style="background-color:${option.color}"
      class="shape-container shape-auto size-40">
    <i class="fa ${option.icon} font-size-20 color-white"></i>
</span>
                                </div>
                                <div class="item-inner">
                                    <div class="item-title-row">
                                        <div class="item-title">${option.promptName}</div>
                                    </div>
                                    <div class="item-text">${option.prompt}</div>
                                </div>
                            </div>
                        </a>
                    </li>
                    ` : '')}
                </ul>
            </div>
        </div>
    </div>
    <div id="popover-selection" class="popover">
        <div class="popover-inner">
            <div class="list no-chevron no-hairlines-between">
                <ul>
                    <li>
                        <div class="item-content item-input item-input-outline item-input-with-info">
                            <div class="item-inner no-padding-bottom">
                                <div class="item-title item-floating-label">Ask to SIMBA</div>
                                <div class="item-input-wrap no-border">
                                    <input type="text" @input="${handlePromptTextArea}" id="ask-simba" class=""/>
                                    <span class="input-clear-button"></span>
                                    <a href="#" class="link popover-close" @click="${() => setPrompt(prompt,1)}"><i
                                            class="icon f7-icons">arrow_up</i></a></div>
                            </div>
                        </div>
                    </li>

                    <li>
                        <a href="#" class="item-link" @click="${highlightForReporting}">
                            <div class="item-content" style="height:10px">
                                <div class="item-media">
                                    <span style=""
                                          class="shape-container shape-auto size-40">
                <i class="fa fa-highlighter color-yellow"></i>
            </span>
                                </div>
                                <div class="item-inner">
                                    <div class="item-title">Highlight for reporting</div>
                                </div>
                            </div>
                        </a>
                    </li>
                    ${chat.instructions.map((option, index) => option.isSelection === 1 ? $h`
                    <li>
                        <a href="#" class="item-link popover-close" @click="${() => setPrompt(option.prompt,1)}">
                            <div class="item-content" style="height:10px">
                                <div class="item-media">
            <span style="background-color:${option.color}"
                  class="shape-container shape-auto size-40">
                <i class="fa ${option.icon} color-white"></i>
            </span>
                                </div>
                                <div class="item-inner">
                                    <div class="item-title-row">
                                        <div class="item-title">${option.promptName}</div>
                                    </div>
                                </div>
                            </div>
                        </a>
                    </li>
                    ` : '')}
                    <li>
                        <a href="#" class="item-link popover-close" @click="${copyToClipboard}">
                            <div class="item-content" style="height:10px">
                                <div class="item-media">
                                    <span style=""
                                          class="shape-container shape-auto size-40">
                <i class="fa fa-copy color-white"></i>
            </span>
                                </div>
                                <div class="item-inner">
                                    <div class="item-title">Copy to clipboard</div>
                                </div>
                            </div>
                        </a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
    <div id="popover-assistants" class="popover" style="min-width: 192px;">
        <div class="popover-inner">
            <div class="list links-list no-chevron no-hairlines no-hairlines-between">
                <ul>
                    ${assistants.map((item, index) => $h`
                    <li>
                        <a href="#" class="popover-close" @click="${() => switchAssistant(item.guid)}">
                            <div class="item-content">
                                <div class="item-media">
                                    <img class="shape-circle" width="40" height="40" src="${item.avatar}"/>

                                </div>
                                <div data-tooltip="${item.name}" class="tooltip-init item-inner">
                                    <div class="item-title">${item.name}</div>
                                    ${item.guid == assistant.guid && $h`
                                    <i class="icon margin-left f7-icons color-primary">checkmark_alt_circle_fill</i>
                                    `}
                                </div>
                            </div>
                        </a>
                    </li>
                    `)}
                </ul>
            </div>
        </div>
    </div>
    <input type="file" id="document-upload" style="display: none;" multiple/>
    <div id="popup-config" class="popup">
        <div class="page">
            <div class="navbar">
                <div class="navbar-bg"></div>
                <div class="navbar-inner">
                    <div class="title">API Configuration</div>
                    <div class="right">
                        <a class="link icon-only" @click="${closePopupConfig}">
                            <i class="icon material-icons">cancel</i>
                        </a>
                    </div>
                </div>
            </div>

            <div class="page-content">
                <div class="block block-strong inset margin-vertical">
                    <div class="margin-top text-align-center">
                        <div class="font-size-24 font-weight-bold">API Configuration</div>
                        <div class="font-size-16 margin-top-half text-color-gray">Configure API connection parameters
                        </div>
                    </div>
                </div>
                <form name="config" action="#" method="POST" enctype="multipart/form-data">
                    <div class="list inset margin-vertical">
                        <ul class="padding-vertical-half">
                            <li>
                                <div class="item-content item-input item-input-outline">
                                    <div class="item-inner">
                                        <div class="item-title item-floating-label">mySim API URL</div>
                                        <div class="item-input-wrap">
                                            <div class="item-media">
                                                <i class="icon material-icons">link</i>
                                            </div>
                                            <input type="text" value="${config.assistantApiUrl}" name="api_url"
                                                   placeholder="API URL" required/>
                                            <span class="input-clear-button"></span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li>
                                <div class="item-content item-input item-input-outline">
                                    <div class="item-inner">
                                        <div class="item-title item-floating-label">Api Key</div>
                                        <div class="item-input-wrap">
                                            <div class="item-media">
                                                <i class="icon material-icons">vpn_key</i>
                                            </div>
                                            <input type="password" name="token" value="${config.assistantAuthToken}"
                                                   placeholder="Authentication token" required/>
                                            <span class="input-clear-button"></span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li>
                                <div class="item-content item-input item-input-outline">
                                    <div class="item-inner">
                                        <div class="item-title item-floating-label">Completion URL</div>
                                        <div class="item-input-wrap">
                                            <div class="item-media">
                                                <i class="icon material-icons">cloud</i>
                                            </div>
                                            <input type="text" name="completion_url" value="${config.completionsApiUrl}"
                                                   placeholder="Completion service URL" required/>
                                            <span class="input-clear-button"></span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li>
                                <div class="item-content item-input item-input-outline">
                                    <div class="item-inner">
                                        <div class="item-title item-floating-label">API Key</div>
                                        <div class="item-input-wrap">
                                            <div class="item-media">
                                                <i class="icon material-icons">security</i>
                                            </div>
                                            <input type="password" name="api_key" value="${config.completionsApiKey}"
                                                   placeholder="API Key for the service" required/>
                                            <span class="input-clear-button"></span>
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li>
                                <div class="item-content">
                                    <div class="item-inner">
                                        <button type="submit" class="button button-fill button-large">Save
                                            Configuration
                                        </button>
                                    </div>
                                </div>
                            </li>
                        </ul>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <div class="popup popup-highlights" id="popup-highlights">
        <div class="view">
            <div class="page">
                <div class="navbar">
                    <div class="navbar-bg"></div>
                    <div class="navbar-inner">
                        <div class="title">Highlighted Texts</div>
                        <div class="right">
                            <a href="#" class="link popup-close">Close</a>
                        </div>
                    </div>
                </div>
                <div class="page-content">
                    <div class="card margin-vertical no-shadow">
                        <div class="card-header">
                            <span>Highlights (${Object.keys(highlights).length})</span>
                            <a href="#" class="link icon-only" @click="${toggleSortableDisable}">
                                <i class="icon material-icons">sort</i>
                            </a>
                        </div>
                        <div class="card-content">
                            <div id="sortable-highlights-list" class="list sortable no-safe-areas">
                                <ul>
                                    ${Object.keys(highlights).length > 0 ? Object.keys(highlights).map((key, index) => $h`
                                    <li  data-highlight-id="${key}">
                                        <div class="cursor-pointer item-content"  @click="${() => scrollToHighlight(key)}">
                                            <div class="item-inner">
                                                <div class="item-title"  style="padding-right: 50px; word-wrap: break-word; overflow-wrap: break-word;">
                                                    ${highlights[key]}
                                                </div>
                                                <div class="item-after" style="position: absolute; right: 25px; top: 50%; transform: translateY(-50%); min-width: 30px;">
                                                    <a href="#" class="link margin-right" data-highlight-id="${key}" @click="${(e) => removeHighlightFromPopup(e, key)}">
                                                        <i class="fa fa-trash color-red"></i>
                                                    </a>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="sortable-handler"></div>
                                    </li>
                                    `) : $h`
                                    <li class="no-sorting">
                                        <div class="item-content">
                                            <div class="item-inner">
                                                <div class="item-title">No highlights found</div>
                                            </div>
                                        </div>
                                    </li>
                                    `}
                                </ul>
                            </div>
                        </div>
                        <div class="card-footer">
                                <button class="button button-fill button-large" @click="${generalAction}">
                                    <i class="fa fa-pencil margin-right"></i>
                                    Create report
                                </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="popover-text" class="popover">
        <div class="popover-inner" style="max-height:200px!important">
            ${myReference ? $h`
            <div class="block-title align-items-center margin-top">
                <span>${myReference.name}</span>

            </div>
            <div class="block margin-bottom">
                <p>${myReference.content}</p>
                <span class="font-size-16 font-weight-normal text-color-gray">Page: ${myReference.page} Section: ${myReference.section}</span>
            </div>
            ` : $h`
            <div class="block text-align-center">
                <span key="preloader" class="preloader"></span>
            </div>
            `}
        </div>
        <div class="popover-footer padding">
            <a href="#" id="view-source" class="button float-left margin-bottom button-small button-round color-white bg-color-chrome link popover-close">
            <i class="fa fa-file margin-right-half"></i>
            <span>View source</span>
           </a>
            <a href="#" id="view-document" class="margin-left-half float-left button margin-bottom button-small button-round color-white bg-color-chrome link popover-close">
                <i class="fa fa-eye margin-right-half"></i>
                <span>View document</span>
            </a>

        </div>
    </div>
    </div>
</template>


<script>


    export default function (props, {$, $el, $f7, $f7route, $f7router, $h, $on, $store, $theme, $update}) {

        let response = '';

        let isScrolling = false;
        let isResponding = null;
        let notFinishedMessage = '';
        let prompt = null;
        let messages = [];
        let messagebar = null;
        let processingToolResponse = false;
        let sources = [];
        let dialogChoiceChip = null;
        let actionsCustomLayout = null;
        let usageData = null;
        let highlights = {};
        let popupHighlights = null;

// Usar la función en lugar de la configuración anterior
        hljs.registerLanguage('stask', function (hljs) {
            // Aquí estamos haciendo que 'stack' utilice la misma definición que 'json'
            return hljs.getLanguage('json');
        });
        let md = window.markdownit({
            html: true,            // ¡Muy importante para seguridad!
            linkify: true,         // Convierte URLs automáticamente en enlaces
            typographer: true,     // Mejores sustituciones tipográficas
            highlight: function (str, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return '<pre class="no-margin-top hljs" data-lang="' + lang + '"><code class="cod-with-auto">' +
                            hljs.highlight(str.replace('<span class="thinking-icon">' + assistant.thinkIcon + '</span>', '').replace('```', ""), {
                                language: lang,
                                ignoreIllegals: true
                            }).value +
                            '</code></pre>';
                    } catch (__) {
                    }
                }

                // Si no hay lenguaje especificado o se produce un error:
                return '<pre class="no-margin-top hljs"><code>' + md.utils.escapeHtml(str.replace('<span class="thinking-icon">' + assistant.thinkIcon + '</span>', '').replace('```', "")) + '</code></pre>';
            }
        }).use(window.texmath, {engine: window.katex, delimiters: 'brackets'});
        let popupTicket = null;
        let formTicketValidator = null;
        let ticket = {
            device: '',
            problem_title: "",
            problem_description: ""
        };
        let scrollToBottomBtn = null;
        let pageContent = null;
        let breakAutoScroll = false;
        let user = {
            guid: '05F1A0C-54F6-5A83-25E0-13EB149B237'
        }
        let assistant = null;
        let assistants = [];
        let quick_actions = [];
        let chat = {
            guid: $f7route.params.guid,
            title: 'New chat',
            instructions: [],
            noSelectionInstructions: []
        }
        let mainSystemMessage = {
            role: "system",
            content: ""//Por favor responde a las preguntas del usuario de manera clara y concisa y para aquiellos casos en los que necesites mas informacion usa las herramientas."
        }
        let messagesHistory = [{
            role: "system",
            content: ""//Por favor responde a las preguntas del usuario de manera clara y concisa y para aquiellos casos en los que necesites mas informacion usa las herramientas."
        },

        ];
        let showCenteredBar = messagesHistory.length === 1;
        let showBottomBar = messagesHistory.length > 1;
        let params = null;
        let selectedText = "";
        let config = {
            completionsApiUrl: window.config.completion.url,
            completionsApiKey: window.config.completion.apiKey,
            assistantApiUrl: window.config.api_url,
            assistantAuthToken: window.config.token
            // theme: localStorage.getItem('theme') || 'light'
        };
        const unlikeReasons = [
            {
                value: "no_solution",
                reason: "Doesn’t solve the issue",
                description: "I followed the steps but the problem persists."
            },
            {
                value: "incorrect",
                reason: "Contains errors",
                description: "The information or steps are wrong."
            },
            {
                value: "incomplete",
                reason: "Missing information",
                description: "Key steps or details are omitted."
            },
            {
                value: "unclear",
                reason: "Hard to understand",
                description: "The instructions are confusing or too technical."
            },
            {
                value: "not_applicable",
                reason: "Not applicable to my setup",
                description: "The steps don’t fit my hardware or configuration."
            },
            {
                value: "other",
                reason: "Other (please specify)",
                description: "The issue doesn’t match any of the above."
            }
        ];
        let popoverSelection = null;
        let devices = [
            // "ARMS",
            "FFS CN235",
            "FFS C295 TS03",
            "FFS C295 EA03",
            "FFS A400M",
            "FTD A400M",
            "CHT-E",
            "CMOS A400M",
            "FFS A330 MRTT",
            "CPTT",
            "DT-MRTT",
            "FMS A400M",
            "LMWS",
            "MPRS",
            "GENERAL",
        ];
        let myDevice = null;
        let footerTemplate = '<div class="message-footer-content"><div class="sources margin-bottom float-left"></div><div class="actions margin-top-half width-100 text-align-right float-right"></div></div>'
        let uploadedFiles = [];
        let isResponseInBackground = false;
        let streamingProgress = 0; // Para la barra de progreso
        let fullStreamingResponse = ""; // Para guardar la respuesta completa
        let isSuggestionsVisible = false;
        let currentMentionPosition = null;
        let selectedSuggestionIndex = -1;
        let filteredAssistants = [];
// Add this function to your existing script
        let popupConfig = null;
        let formConfigValidator = null;
        let currentStreamingRequest = null; // Para guardar referencia a la petición actual
        let popoverText = null;
        let myReference = null;
        $update();
// Constante para el límite de tokens
        const TOKEN_LIMIT = 32000; // Ajusta según necesites
        const MAX_TOKENS= 10000;
        const SUMMARY_MODEL = "mistral-small-24B-instruct-2501"; // Modelo para resumir
        function preprocessMarkdown(text) {
            // Si el texto está vacío o no contiene referencias, devolvemos el texto sin cambios
            if (!text || !text.includes('<reference')) {
                return text;
            }

            // Usamos una expresión regular simple para encontrar todas las etiquetas de referencia
            return text.replace(/<reference\s+([^>]*)>([^<]+)<\/reference>/g, function (match, attributesStr, content) {
                // Creamos un elemento temporal con jQuery para analizar los atributos
                const $tempElement = $('<reference ' + attributesStr + '></reference>');

                // Extraemos todos los atributos data-*
                const filename = $tempElement.attr('data-filename') || '';
                const page = $tempElement.attr('data-page') || '';
                const section = $tempElement.attr('data-section') || '';
                const guid = $tempElement.attr('data-guid') || '';
                const icon = $tempElement.attr('data-icon') || '';

                // Construimos el span de reemplazo con todos los atributos
                let spanHtml = '<span class="reference cursor-pointer badge badge-round bg-color-bluegray"';
                spanHtml += ` data-filename="${filename}" data-content="${content}" data-page="${page}" data-section="${section}"`;

                // Añadimos data-guid solo si existe
                if (guid) {
                    spanHtml += ` data-guid="${guid}"`;
                }

                // Cerramos el span con el contenido visible (filename)
                spanHtml += `><i class="${icon} margin-right-half"></i>${filename}</span>`;

                return spanHtml;
            });
        }

// Función para estimar tokens en un mensaje
        function estimateTokens(message) {
            if (!message || !message.content) return 0;
            return Math.ceil(message.content.length / 4);
        }

// Función para limpiar documentos Simba de un mensaje
        function cleanSimbaDocuments(messageContent) {
            if (!messageContent) return messageContent;

            // Eliminar solo las etiquetas de simba_document y su contenido
            return messageContent.replace(/<simba_document[^>]*>[\s\S]*?<\/simba_document>/g,
                '');
        }


// Función para optimizar tokens eliminando documentos Simba y resumiendo la conversación
        let initializePopoverText = function () {
            popoverText = $f7.popover.create({
                el: $el.value.find('#popover-text'),
                on: {
                    closed: function () {
                        myReference = null;
                        $update();
                    }
                }
            });
        }
        /**
         * Abre un popover con información de texto asociada a una referencia
         * @param {Event} event - El evento que desencadenó la función
         */
        let openPopoverText = function (event) {
            // Obtiene el elemento objetivo (el elemento .reference)
            const targetElement = event.target;

            // Obtiene el GUID del elemento
            const guid = $(targetElement).attr('data-guid');

            // Obtiene el ID del ancestro con clase .message
            const messageElement = $(targetElement).closest('.message');
            const messageId = messageElement.attr('id');

            // Forma la clave del localStorage
            const localStorageKey = "sources_" + messageId;

            // Obtiene los datos de página y sección si existen
            const page = parseInt($(targetElement).attr('data-page'), 10) || undefined;
            const section = parseInt($(targetElement).attr('data-section'), 10) || undefined;
            const name = $(targetElement).attr('data-filename') || 'Referencia no encontrada';
            const content = $(targetElement).attr('data-content') || 'No se pudo encontrar la información de referencia.'

            // Llama a la función para obtener el objeto y el texto
            const result = getObjectAndTextByGuid(localStorageKey, guid, page, section);

            // Si no se encontraron datos, muestra un mensaje simple
            if (!result) {
                myReference = {
                    name: name,
                    page: page || "",
                    section: section || "",
                    content: "..."+content+"..."
                };
            } else {
                // Construye el objeto myReference con los datos recuperados
                myReference = {
                    name: result.sourceObject.id || result.sourceObject.name || "Sin nombre",
                    page: page || (result.sourceObject.extra && result.sourceObject.extra.page) || "",
                    section: section || (result.sourceObject.extra && result.sourceObject.extra.section) || "",
                    content: result.extractedText || "Sin contenido",
                    source: 'https://itc.simeng.es/'+result.sourceObject.source+'#phrase=true&page='+page+'&search='+result.extractedText
                };
            }

            // Abre el popover
            popoverText.open(targetElement);

            // Actualiza la UI
            $update(function () {
                $("#view-source").on('click', function () {
                    openSourcePanel(messageId);
                    $(".source").parent().removeClass('bg-color-chrome');
                    $(".source[id='" + guid + "']").parent().addClass('bg-color-chrome');
                })
                $("#view-document").on('click', function () {
                    console.log(myReference.source);
                    viewDocument(myReference.source,myReference.name,true)
                })



            });
        };
        let initializePopupConfig = function () {
            popupConfig = $f7.popup.create({
                el: $el.value.find('#popup-config')
            });
        };

        let openPopupConfig = function () {
            popupConfig.open();
        };

        let closePopupConfig = function () {
            formConfigValidator.resetForm();
            popupConfig.close();
        };

        let initializeConfigFormValidator = function () {
            formConfigValidator = jQuery($el.value.find('form[name=config]')).validate({
                rules: {
                    api_url: {
                        required: true,
                        url: true
                    },
                    token: {
                        required: true
                    },
                    completion_url: {
                        required: true,
                        url: true
                    },
                    api_key: {
                        required: true
                    }
                },
                messages: {
                    api_url: {
                        required: 'Please enter the API URL.',
                        url: 'Please enter a valid URL.'
                    },
                    token: {
                        required: 'Please enter the authentication token.'
                    },
                    completion_url: {
                        required: 'Please enter the completion service URL.',
                        url: 'Please enter a valid URL.'
                    },
                    api_key: {
                        required: 'Please enter the API Key.'
                    }
                },
                submitHandler: function (form) {
                    // Get form values
                    const formData = $f7.form.convertToData(form);

                    // Update configuration
                    window.config.api_url = formData.api_url;
                    window.config.token = formData.token;
                    window.config.completion.url = formData.completion_url;
                    window.config.completion.apiKey = formData.api_key;

                    // Save to localStorage for persistence
                    localStorage.setItem('completionsApiUrl', formData.completion_url);
                    localStorage.setItem('completionsApiKey', formData.api_key);
                    localStorage.setItem('assistantApiUrl', formData.api_url);
                    localStorage.setItem('assistantAuthToken', formData.token);

                    // Show success message
                    $f7.toast.show({
                        text: 'Configuration saved successfully',
                        cssClass: 'color-green',
                        closeTimeout: 3000
                    });

                    closePopupConfig();
                }
            });
        };

        function renderSourcesInPanel(sources) {
            const container = document.getElementById('panel-sources-content');
            if (!container) return;

            container.innerHTML = `
    <div class="no-shadow">
       <div class="card-content">
        <div class="list media-list margin-top-auto">
          <ul>
            ${sources.map((item) => `
              <li>
                <a href="#" onclick = "viewDocument('https://itc.simeng.es/${item.source}','${item.name}')" id="${item.guid}" class="source color-white link icon-only">
                  <div class="item-content">
                    <div class="item-media"><i class="${item.icon}"></i></div>
                    <div class="item-inner">
                      <div class="source-title item-title">${item.name}</div>
                      <div class="source-summary item-text">${item.summary}</div>
                      <div class="source-extra item-text">${item.site} - ${item.device} - ${item.id}</div>
                    </div>
                  </div>
                </a>
              </li>
            `).join('')}
          </ul>
        </div>
      </div>
    </div>
  `;
        }

        /**
         * Inicializa el buscador de asistentes
         */
        function initAssistantMentions() {
            const textarea = document.getElementById('prompt');
            let suggestionsContainer = document.getElementById('assistants-suggestions');

            if (!textarea) return;

            // Si el contenedor no existe, crearlo
            if (!suggestionsContainer) {
                suggestionsContainer = document.createElement('div');
                suggestionsContainer.id = 'assistants-suggestions';
                suggestionsContainer.className = 'assistants-suggestions';
                suggestionsContainer.innerHTML = `
            <div class="assistants-suggestions-title">Available Assistants</div>
            <div class="assistants-suggestions-list"></div>
        `;
                document.body.appendChild(suggestionsContainer);
            } else {
                // Si existe pero no está en el body, moverlo allí
                if (suggestionsContainer.parentElement !== document.body) {
                    document.body.appendChild(suggestionsContainer);
                }
            }

            // Event listeners para el textarea
            textarea.addEventListener('input', handleTextareaInput);
            textarea.addEventListener('keydown', handleTextareaKeydown);

            // Event listener para hacer clic fuera y cerrar las sugerencias
            document.addEventListener('click', function (e) {
                if (suggestionsContainer && !suggestionsContainer.contains(e.target) && e.target !== textarea) {
                    hideSuggestions();
                }
            });
        }

        /**
         * Maneja el evento input en el textarea
         */
        function handleTextareaInput(e) {
            const textarea = e.target;
            const text = textarea.value;
            const caretPosition = textarea.selectionStart;

            // Comprobar si estamos escribiendo una mención (@)
            const mentionPosition = findMentionPosition(text, caretPosition);

            if (mentionPosition !== null) {
                // Guardar la posición de la mención
                currentMentionPosition = mentionPosition;

                // Obtener el texto después de @
                const query = text.substring(mentionPosition + 1, caretPosition).toLowerCase();

                // Filtrar los asistentes según la consulta
                filterAssistants(query);

                // Mostrar sugerencias
                showSuggestions();
            } else {
                // Si no estamos en una mención, ocultar sugerencias
                hideSuggestions();
            }
        }

        /**
         * Busca la posición de la mención en el texto
         * @param {string} text - El texto completo
         * @param {number} caretPosition - La posición actual del cursor
         * @returns {number|null} - La posición de la @ o null si no está en una mención
         */
        function findMentionPosition(text, caretPosition) {
            // Buscar hacia atrás desde la posición del cursor hasta encontrar @ o un espacio
            for (let i = caretPosition - 1; i >= 0; i--) {
                if (text[i] === '@') {
                    // Verificar que @ es el inicio de una palabra
                    if (i === 0 || /\s/.test(text[i - 1])) {
                        return i;
                    }
                } else if (/\s/.test(text[i])) {
                    // Si encontramos un espacio antes de @, no estamos en una mención
                    return null;
                }
            }
            return null;
        }

        /**
         * Filtra los asistentes según la consulta
         * @param {string} query - El texto después de @
         */
        function filterAssistants(query) {
            // Filtrar asistentes basados en el query
            filteredAssistants = assistants.filter(assistant =>
                assistant.name.toLowerCase().includes(query)
            );

            // Restablecer el índice seleccionado
            selectedSuggestionIndex = filteredAssistants.length > 0 ? 0 : -1;

            // Renderizar la lista de sugerencias
            renderSuggestionsList();
        }

        /**
         * Renderiza la lista de sugerencias
         */
        function renderSuggestionsList() {
            const suggestionsList = document.querySelector('.assistants-suggestions-list');
            if (!suggestionsList) return;

            // Limpiar la lista
            suggestionsList.innerHTML = '';

            // Si no hay búsqueda, añadir campo de búsqueda
            if (filteredAssistants.length > 10) {
                const searchDiv = document.createElement('div');
                searchDiv.className = 'assistant-search-input';
                searchDiv.innerHTML = `<input type="text" placeholder="Search assistants...">`;
                suggestionsList.appendChild(searchDiv);

                // Añadir event listener para la búsqueda
                const searchInput = searchDiv.querySelector('input');
                searchInput.addEventListener('input', function (e) {
                    const searchQuery = e.target.value.toLowerCase();
                    filterAssistants(searchQuery);
                });
                searchInput.focus();
            }

            // Añadir los asistentes filtrados
            filteredAssistants.forEach((assistant, index) => {
                const item = document.createElement('div');
                item.className = 'assistant-suggestion-item';
                item.title = assistant.description;
                if (index === selectedSuggestionIndex) {
                    item.classList.add('selected');
                }

                item.innerHTML = `
            <div class="assistant-suggestion-avatar">
                <img src="${assistant.avatar}" alt="${assistant.name}">
            </div>
            <div class="assistant-suggestion-info">
                <div class="assistant-suggestion-name">${assistant.name}</div>
                <div  class="assistant-suggestion-description">${assistant.description || 'Assistant'}</div>
            </div>
        `;

                // Event listener para hacer clic en un asistente
                item.addEventListener('click', function () {
                    insertAssistantMention(assistant);
                });

                suggestionsList.appendChild(item);
            });

            // Si no hay resultados, mostrar mensaje
            if (filteredAssistants.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'assistant-suggestion-item';
                noResults.textContent = 'No assistants found';
                suggestionsList.appendChild(noResults);
            }
        }

        /**
         * Muestra las sugerencias en la posición adecuada
         */
        function showSuggestions() {
            const textarea = document.getElementById('prompt');
            const suggestionsContainer = document.getElementById('assistants-suggestions');

            if (!textarea || !suggestionsContainer) return;

            // Calcular la posición para mostrar las sugerencias
            const textareaRect = textarea.getBoundingClientRect();
            const lineHeight = parseInt(window.getComputedStyle(textarea).lineHeight);

            // Verificar si el textarea está en el footer o en el centro
            const isInFooter = isTextareaInFooter(textarea);

            if (isInFooter) {
                // Si está en el footer, colocar las sugerencias arriba del textarea
                suggestionsContainer.style.bottom = `${window.innerHeight - textareaRect.top + 10}px`;
                suggestionsContainer.style.top = 'auto';
                suggestionsContainer.style.left = `${textareaRect.left + 20}px`;
                suggestionsContainer.style.maxHeight = `${Math.min(300, textareaRect.top - 50)}px`;
            } else {
                // Si está en el centro, colocar las sugerencias debajo del textarea
                suggestionsContainer.style.top = `${textareaRect.top + lineHeight + 10}px`;
                suggestionsContainer.style.bottom = 'auto';
                suggestionsContainer.style.left = `${textareaRect.left + 20}px`;
                suggestionsContainer.style.maxHeight = '300px';
            }

            // Asegurar que no se salga de la pantalla horizontalmente
            const rightEdge = textareaRect.left + 20 + 300; // 300px es el ancho del contenedor
            if (rightEdge > window.innerWidth) {
                suggestionsContainer.style.left = `${window.innerWidth - 320}px`; // 20px de margen
            }

            // Mostrar el contenedor
            suggestionsContainer.style.display = 'block';
            isSuggestionsVisible = true;
        }

        /**
         * Verifica si el textarea está en el footer
         * @param {HTMLElement} textarea - El elemento textarea
         * @returns {boolean} - True si está en el footer, false en caso contrario
         */
        function isTextareaInFooter(textarea) {
            // Comprobar si el textarea está en el toolbar del footer
            let parent = textarea;

            // Subir en el DOM para buscar un elemento con clase messagebar o toolbar
            while (parent && parent !== document.body) {
                if (parent.classList.contains('messagebar') ||
                    parent.classList.contains('toolbar') ||
                    parent.classList.contains('messagebar-chat') ||
                    parent.id === 'page-toolbar') {
                    return true;
                }
                parent = parent.parentElement;
            }

            // Alternativamente, podemos verificar la posición vertical en la ventana
            const rect = textarea.getBoundingClientRect();
            const windowHeight = window.innerHeight;

            // Si el textarea está en la mitad inferior de la pantalla, probablemente está en el footer
            return rect.top > windowHeight / 2;
        }

        /**
         * Oculta las sugerencias
         */
        function hideSuggestions() {
            const suggestionsContainer = document.getElementById('assistants-suggestions');
            if (suggestionsContainer) {
                suggestionsContainer.style.display = 'none';
            }
            isSuggestionsVisible = false;
            currentMentionPosition = null;
            selectedSuggestionIndex = -1;
        }

        /**
         * Maneja las teclas de navegación en las sugerencias
         */
        function handleTextareaKeydown(e) {
            if (!isSuggestionsVisible) return;

            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    if (selectedSuggestionIndex < filteredAssistants.length - 1) {
                        selectedSuggestionIndex++;
                        renderSuggestionsList();
                    }
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    if (selectedSuggestionIndex > 0) {
                        selectedSuggestionIndex--;
                        renderSuggestionsList();
                    }
                    break;

                case 'Enter':
                    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < filteredAssistants.length) {
                        e.preventDefault();
                        insertAssistantMention(filteredAssistants[selectedSuggestionIndex]);
                    }
                    break;

                case 'Escape':
                    e.preventDefault();
                    hideSuggestions();
                    break;
            }
        }

        /**
         * Inserta la mención del asistente en el textarea
         * @param {Object} assistant - El asistente seleccionado
         */
        function insertAssistantMention(assistant) {
            hideSuggestions();

            switchAssistant(assistant.guid);

            const textarea = document.getElementById('prompt');
            textarea.value = "";
            prompt = ' ';
            return false;
            if (!textarea || currentMentionPosition === null) return;

            const text = textarea.value;
            const caretPosition = textarea.selectionStart;

            // Crear el texto para reemplazar en el textarea
            const beforeMention = text.substring(0, currentMentionPosition);
            const afterMention = text.substring(caretPosition);

            // Reemplazar @query con @nombre
            const newText = beforeMention + '@' + assistant.name + ' ' + afterMention;

            // Actualizar el textarea
            textarea.value = newText;

            // Establecer la posición del cursor después de la mención
            const newPosition = currentMentionPosition + assistant.name.length + 2; // +2 por @ y espacio
            textarea.setSelectionRange(newPosition, newPosition);

            // Para Framework7, a veces necesitamos disparar un evento input para actualizar el binding
            const inputEvent = new Event('input', {bubbles: true});
            textarea.dispatchEvent(inputEvent);

            // Si estamos usando variables reactivas de Framework7, actualizar explícitamente
            prompt = textarea.value;
            $update();

            // Actualizar la altura del textarea si es auto-height
            if (typeof $f7 !== 'undefined' && textarea.classList.contains('auto-height')) {
                $f7.input.resizeTextarea(textarea);
            }

            // Ocultar sugerencias
            hideSuggestions();

            // Enfocar de nuevo el textarea
            setTimeout(() => {
                textarea.focus();
            }, 50);
        }

        let createConversation = function (guid) {
            return new Promise((resolve, reject) => {
                $f7.request({
                    url: `${window.config.api_methods.create_chat}?assistant=` + guid,
                    method: 'GET',
                    headers: {
                        'x-auth-token': window.config.token,
                        'Content-Type': 'application/json'
                    },
                    dataType: 'json'
                }).then((response) => {
                    // Procesar response.data aquí
                    chat = response.data.data;
                    chat.noSelectionInstructions = chat.instructions ? chat.instructions.filter(instruction => !instruction.isSelection) : [];
                    mainSystemMessage.content = chat.mainAssistant.system;
                    console.log(mainSystemMessage);
                    assistant.name = chat.mainAssistant.name;
                    assistant.avatar = 'https://survey.simeng.es' + chat.mainAssistant._myMedias.avatars[0].realPath;
                    assistant.mainImage = 'https://survey.simeng.es' + chat.mainAssistant._myMedias.mainImage[0].realPath
                    assistant.greeting = chat.mainAssistant.greeting;
                    assistant.placeholder = chat.mainAssistant.placeholder;
                    $update();
                    console.log('Respuesta:', response.data);
                    resolve(response.data); // Resuelve la promesa con la respuesta
                }).catch((error) => {
                    console.error('Error:', error);
                    reject(error); // Rechaza la promesa en caso de error
                });
            });
        }
        /**
         * Busca un objeto por su GUID y devuelve tanto el objeto como el texto relevante
         * @param {string} localStorageKey - La clave del localStorage donde buscar
         * @param {string} guid - El GUID del objeto que se quiere encontrar
         * @param {number} [page] - Número de página opcional
         * @param {number} [section] - Número de sección opcional
         * @returns {Object|null} - Objeto con propiedades 'sourceObject' y 'extractedText', o null si no se encuentra
         */
        let getObjectAndTextByGuid = function (localStorageKey, guid, page, section) {
            try {
                // Obtener el contenido de la clave del localStorage
                const storedData = localStorage.getItem(localStorageKey);

                // Si no hay datos almacenados, retornar null
                if (!storedData) {
                    console.error(`No se encontraron datos en la clave ${localStorageKey}`);
                    return null;
                }

                // Parsear los datos como JSON
                const parsedData = JSON.parse(storedData);

                // Verificar si hay una propiedad 'sources'
                if (!parsedData.sources || !Array.isArray(parsedData.sources)) {
                    console.error(`Formato de datos inesperado en ${localStorageKey}`);
                    return null;
                }

                // Buscar el objeto con el GUID especificado
                const foundObject = parsedData.sources.find(item => item.guid === guid);

                // Si no se encontró el objeto, retornar null
                if (!foundObject) {
                    console.error(`No se encontró objeto con GUID ${guid}`);
                    return null;
                }

                // Variable para almacenar el texto extraído
                let extractedText = null;

                // Si se proporcionaron página y sección, buscar en referencias
                if (page !== undefined && section !== undefined) {
                    // Verificar si el objeto tiene referencias
                    if (foundObject.references && Array.isArray(foundObject.references)) {
                        // Buscar la referencia específica
                        const foundReference = foundObject.references.find(ref =>
                            ref.page === page && ref.section === section
                        );

                        // Si se encontró la referencia, usar su texto
                        if (foundReference) {
                            extractedText = foundReference.text;
                        }
                    }
                }

                // Si no se encontró referencia específica, usar fragmento del texto general
                if (extractedText === null && foundObject.text) {
                    const words = foundObject.summary ? foundObject.summary.split(/\s+/) : foundObject.text.split(/\s+/);
                    extractedText = words.slice(0, 10).join(' ') + (words.length > 10 ? '...' : '');
                }

                // Retornar el objeto resultante con ambas propiedades
                return {
                    sourceObject: foundObject,
                    extractedText: extractedText
                };

            } catch (error) {
                // Capturar errores como JSON inválido
                console.error(`Error al procesar GUID ${guid} en ${localStorageKey}:`, error);
                return null;
            }
        }

        function buildSimbaPromptFromSources(sources) {
            const blocks = [];

            for (const source of sources) {
                // Si hay references, usarlas
                if (Array.isArray(source.references) && source.references.length > 0) {
                    const name = source.id || source.name;
                    const guid = source.guid || "";
                    const icon = source.icon || "";

                    for (const ref of source.references) {
                        const page = ref.page ?? "";
                        const section = ref.section ?? "";
                        const text = (ref.text || "").trim();

                        const block = `<simba_document data-icon="${icon}" data-filename="${name}" data-guid="${guid}" data-page="${page}" data-section="${section}">\n${text}\n</simba_document>`;
                        blocks.push(block);
                    }
                }
                // Si no hay references pero hay texto, crear un documento simba con el texto completo
                else if (source.text) {
                    const name = source.id || source.name;
                    const guid = source.guid || "";
                    const text = source.text.trim();
                    const icon = source.icon || ""

                    const block = `<simba_document data-icon="${icon}" data-filename="${name}" data-guid="${guid}">\n${text}\n</simba_document>`;
                    blocks.push(block);
                }
            }

            return blocks.join("\n\n");
        }

        let addActionsToMessage = function (object) {
            function extractMessageTextWithoutFooter(messageId) {
                // Get the target element by ID
                var targetElement = document.getElementById(messageId);
                if (!targetElement) {
                    console.error("Element with ID " + messageId + " not found");
                    return null;
                }

                // Find the message-text element
                var messageTextElement = targetElement.querySelector(".message-text");
                if (!messageTextElement) {
                    console.error("Element with class 'message-text' not found");
                    return null;
                }

                // Clone the message-text element to avoid modifying the original
                var messageTextClone = messageTextElement.cloneNode(true);

                // Find and remove all message-text-footer elements from the clone
                var footers = messageTextClone.querySelectorAll(".message-text-footer");
                footers.forEach(function (footer) {
                    footer.parentNode.removeChild(footer);
                });

                // Get the HTML content without the footer
                var cleanedHtml = messageTextClone.innerHTML;

                return cleanedHtml;
            }

            // Verificar si ya existe un footer, si no, crearlo
            let $footer = object.find('.message-text-footer');
            $footer.appendTo(object.find('.message-text'));
            if ($footer.length === 0) {
                $footer = $('<div class="message-text-footer"></div>');
                object.find('.message-text').append($footer);

                // Crear la estructura del footer con las dos secciones
                $footer.html(footerTemplate);
            }
            $footer.find('.message-footer-content').attr('data-message-id', object.attr('id'))
            // Obtener referencia a la sección derecha
            const $rightSection = $footer.find('.actions');

            // Crear HTML para las acciones
            const actionsHTML = `
         <a class="link  action-button margin-left-half" data-action="edit" data-message-id="${object.attr('id')}">
            <i class="tooltip-init color-gray font-size-16 icon material-icons-outlined" data-tooltip="Edit content">edit</i>
        </a>
        <a class="link  action-button margin-left-half" data-action="copy" data-message-id="${object.attr('id')}">
            <i class="tooltip-init color-gray font-size-16 icon material-icons-outlined" data-tooltip="Copy message">content_copy</i>
        </a>
        <a class=" link action-button margin-left-half" data-action="like" data-message-id="${object.attr('id')}">
            <i class="tooltip-init color-gray font-size-16 icon material-icons-outlined" data-tooltip="This response is usefull">thumb_up</i>
        </a>
        <a class="link  action-button margin-left-half" data-action="dislike" data-message-id="${object.attr('id')}">
            <i class="tooltip-init color-gray font-size-16 icon material-icons-outlined" data-tooltip="This response is not usefull">thumb_down</i>
        </a>
    `;

            // Añadir el HTML a la sección derecha
            $rightSection.html(actionsHTML);


            // Añadir event listeners para las acciones
            $rightSection.find('.action-button').on('click', function () {
                const action = $(this).data('action');
                const messageId = $(this).data('message-id');

                switch (action) {
                    case 'edit':

                        editContent(extractMessageTextWithoutFooter(messageId), "my_editor", "my_file");
                        break;
                    case 'copy':
                        var targetElement = document.getElementById(messageId); // Selecciona el elemento por ese ID
                        var text = $(targetElement).find(".message-text").text();

                        copyDivToClipboardWithStructure(text, true);
                        break;
                    case 'like':
                        likeMessage(messageId);
                        break;
                    case 'dislike':
                        dialogChoiceChip.open();
                        //    dislikeMessage(messageId);
                        break;
                    default:
                        console.log('Unknown action:', action);
                }
            });
        };
        let addSourcesToMessage = function (object) {
            const messageSources = getSourcesByMessageId(object.attr('id'));

            // Verificar si ya existe un footer, si no, crearlo
            let $footer = object.find('.message-text-footer');

            $footer.appendTo(object.find('.message-text'));
            if ($footer.length === 0) {
                $footer = $('<div class="message-text-footer"></div>');
                object.find('.message-text').append($footer);

                // Crear la estructura del footer con las dos secciones
                $footer.html(footerTemplate);
            }

            // Obtener referencias a las secciones izquierda y derecha
            const $leftSection = $footer.find('.sources');

            // Añadir fuentes a la sección izquierda
            if (messageSources && messageSources.length > 0) {
                // Agrupar fuentes por icono
                const groupedByIcon = {};

                // Recorrer todas las fuentes para agruparlas
                messageSources.forEach(source => {
                    const iconClass = source.icon || 'fa-solid fa-question'; // Icono por defecto

                    // Si el grupo de este icono no existe, crearlo
                    if (!groupedByIcon[iconClass]) {
                        groupedByIcon[iconClass] = {
                            icon: iconClass,
                            count: 0,
                            names: []
                        };
                    }

                    // Incrementar contador y añadir nombre a la lista
                    groupedByIcon[iconClass].count++;
                    groupedByIcon[iconClass].names.push(source.name);
                });

                // Convertir el objeto de grupos a un array
                const uniqueIcons = Object.values(groupedByIcon);

                // Mostrar máximo 5 iconos únicos
                const visibleIcons = uniqueIcons.slice(0, 5);
                const remainingIconTypes = uniqueIcons.length > 5 ? uniqueIcons.length - 5 : 0;

                let sourcesHTML = '';
                // Crear el grupo de avatares para las fuentes
                sourcesHTML += ' <span id="source-' + object.attr('id') + '" class="link font-size-14 badge badge-round badge-outline">';

                // Añadir cada tipo de icono único
                visibleIcons.forEach(iconGroup => {
                    // Crear tooltip con los nombres de las fuentes de este tipo
                    const tooltipText = iconGroup.names.join(', ');

                    // Si hay más de 1 fuente con este icono, mostrar contador
                    let badge = '';
                    if (iconGroup.count > 1) {
                        // badge = `<span class="badge margin-left">${iconGroup.count}</span>`;
                    }

                    sourcesHTML += `<i data-tooltip="${tooltipText}" class="margin-half ${iconGroup.icon} fa-icon">${badge}</i>`;
                });

                // Mostrar "Sources" al final
                sourcesHTML += '<span class="margin-left-half">Sources</span></span>';

                // Añadir el HTML de las fuentes a la sección izquierda del footer
                $leftSection.html(sourcesHTML);

                // Agregar el evento click para mostrar el panel de fuentes
                $("#source-" + object.attr('id')).on('click', function () {
                    const messageId = object.attr('id');
                    openSourcePanel(messageId);

                });
            }
        };
        let openSourcePanel = function (messageId) {
            if (messageId) {
                const messageSources = getSourcesByMessageId(messageId);
                if (messageSources && messageSources.length > 0) {
                    console.log('Sources para el mensaje:', messageSources);
                    renderSourcesInPanel(messageSources);
                    $(".source").each(function () {


                        $(this).on('mouseover touchstart', function () {
                            var elementId = $(this).attr('id');

                            // Buscar todos los elementos con class="reference" y data-guid igual al id del elemento
                            $('.reference[data-guid="' + elementId + '"]').addClass('listening-button');

                        }).on('mouseout touchend', function () {
                            var elementId = $(this).attr('id');

                            // Quitar la clase listening-button de los elementos correspondientes
                            $('.reference[data-guid="' + elementId + '"]').removeClass('listening-button');
                        });
                    })
                    app.panel.open('right')
                    // Aquí podrías abrir el panel de sources si existe
                }
            }
        }
        let switchAssistant = function (guid) {
            let foundAssistant = assistants.find(item => item.guid === guid);

            if (foundAssistant) {
                assistant = foundAssistant;
                createConversation(assistant.guid)
                $update();
            } else {
                console.error("No se encontró ningún asistente con el GUID especificado.");
            }
        }
        let loadAssistants = function () {
            return new Promise((resolve, reject) => {
                $f7.request({
                    url: window.config.api_methods.load_assistants,
                    method: 'GET',
                    headers: {
                        'X-AUTH-TOKEN': window.config.token
                    },
                    success: function (responseText) {
                        var data = JSON.parse(responseText);
                        assistants = data.data.assistants;
                        quick_actions = data.data.quick_actions; // Extraer quick_actions

                        if (assistants.length > 0) {
                            if ('assistant' in $f7route.query) {
                                assistant = assistants.find(assistant => assistant.guid === $f7route.query.assistant);
                            } else {
                                assistant = assistants[0];
                                switchAssistant(assistant.guid)
                            }
                            $update();
                            console.log(assistant);
                            // Devolvemos tanto assistant como quick_actions
                            resolve({
                                assistant: assistant,
                                quick_actions: quick_actions
                            });
                        } else {
                            console.error("El array 'assistants' está vacío.");
                            resolve({
                                assistant: null,
                                quick_actions: quick_actions
                            });
                        }
                    },
                    error: function (xhr, status, error) {
                        $f7.toast.show({
                            text: 'An error occured: ' + error,
                            cssClass: 'color-red'
                        });
                        reject(error);
                    }
                });
            });
        };
        let initializeDialogChoiceChip = function () {
            dialogChoiceChip = $f7.dialog.create({
                el: $el.value.find('#dialog-choice-chip'),
                on: {
                    close: function (dialog) {
                        dialog.$el.find('form')[0].reset();
                    }
                }
            });
        }

        let showDialogChoiceChip = function () {
            dialogChoiceChip.open();
        }
        function scrollToHighlight(highlightId) {
            // Cerrar el popup primero
           /* if (popupHighlights) {
                popupHighlights.close();
            }*/

            // Buscar el elemento destacado en la página
            const highlightElement = document.getElementById(highlightId);

            if (highlightElement) {
                // Scroll suave hasta el elemento
                highlightElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',  // Centrar verticalmente
                    inline: 'nearest'
                });

                // Opcional: Hacer un efecto visual temporal
                highlightElement.style.transition = 'all 0.3s ease';
                highlightElement.style.transform = 'scale(1.05)';
                highlightElement.style.boxShadow = '0 0 20px rgba(255, 255, 0, 0.8)';

                // Quitar el efecto después de 1 segundo
                setTimeout(() => {
                    highlightElement.style.transform = 'scale(1)';
                    highlightElement.style.boxShadow = 'none';
                }, 1000);

                // Toast para confirmar
                app.toast.create({
                    text: 'Scrolled to highlighted text',
                    position: 'center',
                    closeTimeout: 1500,
                }).open();

            } else {
                app.toast.create({
                    text: 'Highlight not found on page',
                    position: 'center',
                    closeTimeout: 1500,
                }).open();
            }
        }
        let closeDialogChoiceChip = function () {
            dialogChoiceChip.close();
        }

        let submitFormDialogChoiceChip = function () {
            let form = dialogChoiceChip.$el.find('form');
            let formData = $f7.form.convertToData(form);
            form[0].reset();
            if (formData.interests.length) {
                $f7.toast.show({
                    text: 'Your feedback(s): ' + formData.interests.join(', ')
                });
            }
            dialogChoiceChip.close();
        }
        let onMessageAdded = function (object) {
            showCenteredBar = messagesHistory.length === 1;
            showBottomBar = messagesHistory.length > 1;
            $update();
            if (showBottomBar) {
                const pageToolbar = document.getElementById('page-toolbar');
                const promptArea = document.getElementById('prompt-area');

                // Verificar si pageToolbar existe en el DOM
                if (pageToolbar) {
                    console.log('Page toolbar encontrado');

                    // Mover el elemento completo al toolbar
                    pageToolbar.appendChild(promptArea);
                }

            }
            object.find('.message-name').addClass('card-header').remove();
            object.find('table').each(function (index) {
                // Add data-table class as before
                this.classList.add('data-table');

                // Create a unique ID for this table if it doesn't have one
                const tableId = this.id || 'data-table-' + Date.now() + '-' + index;
                this.id = tableId;

                // Create container element
                const container = document.createElement('div');
                container.className = 'table-container margin-bottom';
                container.id = 'container-' + tableId;

                // Create export button
                const exportButton = document.createElement('a');
                exportButton.href = '#';
                exportButton.className = 'export-csv-button float-right margin-bottom-half margin-right-half';
                exportButton.innerHTML = '<i class="fa fa-download"></i> CSV';
                exportButton.dataset.table = tableId;
                exportButton.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetTableId = this.dataset.table;
                    exportTableToCSV(document.getElementById(targetTableId));
                });

                // Insert our new elements
                const parent = this.parentNode;
                parent.insertBefore(container, this);
                container.appendChild(exportButton);
                container.appendChild(this);
            });
            object.find('pre').each(function () {

                $(this).addClass('block block-strong inset margin-vertical')
                var codeClass = $(this).find('code').attr('class');
                if (typeof codeClass !== 'undefined' && codeClass != null) {
                    var language = codeClass.match(/language-(\w+)/)[1];
                    $(this).prepend('<div class="bg-color-black float-right padding-half small language-name">' + language + '</div>');
                }
            })
            //    hljs.highlightAll()
            object.on('mouseenter touchstart', function () { // Reemplaza '.object-selector' con tu selector real
                $(this).find(".message-footer-content .actions").show()
                if (!isScrolling) {
                    //$(this).find('.message-text-footer').css('visibility', 'visible');
                    //navigator.vibrate(200);
                }
            }).on('mouseleave touchend', function () {
                $(this).find(".message-footer-content .actions").hide()
                if (!isScrolling) {
                    // navigator.vibrate(0);
                    // $(this).find('.message-text-footer').css('visibility', 'hidden');
                }
            });


            //   scrollToBottom();
        }
        let scrollToBottom = function () {
            pageContent.scrollTo({
                top: pageContent.scrollHeight,
                behavior: 'smooth'
            });
        }
        /**
         * Función para llamar a una herramienta basada en el nombre y parámetros recibidos.
         * Esta función se invoca después de recibir el JSON correspondiente a una herramienta.
         *
         * @param {string} name - Nombre de la herramienta a ejecutar
         * @param {object} params - Parámetros para la herramienta
         * @returns {Promise} - Promise que resuelve con el resultado de la herramienta
         */
        let callTool = function (name, params) {

            console.log(`Llamada a herramienta: ${name}`);
            console.log('Parámetros:', params);
            console.log(`Calling tool: ${name} with params:`, params);

            params['device'] = myDevice;
          //  params['query_type'] = "other";
            // Display a readable message about the search
            let searchText = params.text || "";
            let queryType = params.query_type || "";
            let toolSetup = chat.tools_setup[name];
            console.log("Configuracion de herramienta: ", toolSetup);
            let inProgressMessage = toolSetup['in_progress_message'] ?? 'Calling tool';
            let askForExecution = toolSetup['ask_for_execution'] ?? false;
            let toolIcon = toolSetup['icon'] ?? "fa-database";
            let humanReadableMessage = `<p><div class="call-execution shimmer-text-fast"><i class="fa ${toolIcon} margin-right -half"></i>${inProgressMessage} <strong>${searchText}</strong> in all <strong>${queryType || "available sources"}</strong></div></p>`;

            $el.value.find('.message:last-child .message-text').html(humanReadableMessage);
            if (askForExecution && name == "action_open_support_ticket") {
                ticket = params;
                $update();
                openPopupTicket();
                return;
            }

            // Mark that we're processing a tool response
            processingToolResponse = true;
            window.tempSources = [];

            console.log(params)
            if (params["title"]) {
                chat.title = params["title"].charAt(0).toUpperCase() + params["title"].slice(1);
                $update();
            }
            const payload = {
                name: name,
                params: params,
                chat: chat.guid
            };

            return new Promise((resolve, reject) => {
                $f7.request({
                    url: window.config.api_methods.call_tool,
                    method: 'POST',
                    data: payload,
                    contentType: 'application/json',
                    dataType: 'json',
                    headers: {
                        'x-auth-token': window.config.token
                    },
                    success: function (data, status, xhr) {
                        console.log("Llamada a herramienta completada con éxito:", data);
                        if (data && data.data && data.data["tool_domain"] == 'action') {

                            console.log("Ticket creado", data);
                            return
                        }
                        // Procesar la respuesta: extraer y concatenar los sources
                        if (data && data.data && Array.isArray(data.data.sources)) {
                            // Concatenar todos los sources en un solo texto
                            let sourcesContent = "";
                            sources = data.data.sources;
                            renderSourcesInPanel(sources);
                            window.tempSources = sources;
                            console.log('Sources guardados temporalmente, se asociarán con el ID del mensaje cuando se cree');

                            // Verificar si hay sources con texto
                            let hasSourcesWithText = false;
                            data.data.sources.forEach((source, index) => {
                                if (source.text) {
                                    hasSourcesWithText = true;
                                    if (index > 0) {
                                        sourcesContent += "\n\n---\n\n"; // Separador entre fuentes
                                    }
                                    sourcesContent += source.text;
                                }
                            });

                            // Obtener la última pregunta del usuario de messagesHistory
                            let lastUserQuestion = "";
                            for (let i = messagesHistory.length - 1; i >= 0; i--) {
                                if (messagesHistory[i].role === 'user') {
                                    lastUserQuestion = messagesHistory[i].content;
                                    break;
                                }
                            }

                            // Si encontramos contenido de sources
                            if (hasSourcesWithText) {
                                console.log("Añadiendo contenido de sources como mensaje del usuario");

                                // Añadir el contenido como un mensaje del usuario incluyendo la pregunta original
                                // messagesHistory[0].content = messagesHistory[0].content + '\n\n\n\nPLEASE USE THIS RETRIEVED CONTEXT FOR ANSWERING:\n\n' + sourcesContent;
                                /* messagesHistory.push({
                                     role: 'user',
                                     content: 'Could you answer my last question?',
                                 });*/
                                const simbaPrompt = buildSimbaPromptFromSources(data.data.sources);
                                messagesHistory[0].content = mainSystemMessage.content + '\n\n\n\nPLEASE USE THIS RETRIEVED CONTEXT FOR ANSWERING:\n\n' + simbaPrompt;
                                // Encontrar el último mensaje del usuario
                                /*   for (let i = messagesHistory.length - 1; i >= 0; i--) {
                                       if (messagesHistory[i].role === 'user') {
                                           // Guardar el prompt original del usuario
                                           const userPrompt = messagesHistory[i].content;

                                           // Reemplazar el contenido con el prompt original seguido de los documentos Simba
                                           messagesHistory[i].content =simbaPrompt+"\n\n"+userPrompt;
                                           break;
                                       }
                                   }*/
                                // Señalizar que se han añadido sources a la conversación
                                resolve({
                                    status: 'success',
                                    sourcesAdded: true,
                                    message: 'Se han añadido sources como mensaje del usuario',
                                    originalResponse: data
                                });
                                $(".shimmer-text-fast").removeClass("shimmer-text-fast")
                            } else {
                                console.log("No se encontraron fuentes con información relevante");

                                // En lugar de un mensaje predefinido, dejemos que el companion elabore la respuesta

                                // Generate a new unique ID for the next response
                                const noInfoMsgId = "assistant-no-info-" + Date.now();

                                // Create a new message for processing
                                messages.addMessage({
                                    attrs: {
                                        "data-id": noInfoMsgId,
                                        "id": noInfoMsgId
                                    },
                                    isTitle: false,
                                    text: '<p>Lo siento no se ha encontrado registros. Formula tu pregunta de otra forma</p>',
                                    name: assistant.name,
                                    cssClass: 'card no-margin-top padding-half',
                                    textFooter: footerTemplate,
                                    avatar: assistant.avatar,//'https://ui-avatars.com/api/?background=FFF00&name=' + assistant.name.replace(" ", "%20"),
                                    type: 'received',
                                }, 'append', true);

                                onMessageAdded($('#' + noInfoMsgId));
                                if (window.tempSources && window.tempSources.length > 0) {
                                    const sourceArray = {
                                        "sources": window.tempSources,
                                        "params": params
                                    }
                                    localStorage.setItem('sources_' + noInfoMsgId, JSON.stringify(sourceArray));
                                    console.log('Sources guardados en localStorage con clave:', 'sources_' + noInfoMsgId);
                                }
                             //   SourcesManager.save(noInfoMsgId, params);
                                //    scrollToBottom();
                                messagesHistory.push({
                                    role: 'assistant',
                                    content: "Lo siento no se ha encontrado registros. Formula tu pregunta de otra forma."
                                })
                                // Añadir un mensaje para que el modelo sepa que no se encontró información
                                messagesHistory.push({
                                    role: 'user',
                                    content: "Respecto a mi pregunta: \"" + lastUserQuestion + "\", he intentado buscar información adicional pero no he encontrado datos relevantes. Por favor, dile al usuario que no encuentras información o solicita la informacion necesaria para realizar una nueva busqueda."
                                });

                                // Llamar a callCompletion para que el modelo elabore la respuesta
                                callCompletion(false, noInfoMsgId)
                                    .then(() => {
                                        processingToolResponse = false;
                                        // Resolver después de que se genere la respuesta
                                        resolve({
                                            status: 'success',
                                            sourcesAdded: false,
                                            message: 'Se ha generado una respuesta por el companion para el caso sin datos',
                                            originalResponse: data
                                        });
                                    })
                                    .catch(error => {
                                        processingToolResponse = false;
                                        console.error("Error en la generación de respuesta para el caso sin datos:", error);
                                        // Aún resolver para no interrumpir el flujo
                                        resolve({
                                            status: 'success',
                                            sourcesAdded: true,
                                            message: 'Error en la generación de respuesta para el caso sin datos',
                                            originalResponse: data,
                                            error: error
                                        });
                                    });
                            }

                        } else {
                            console.log("La respuesta no contiene la estructura de sources esperada");

                            // Obtener la última pregunta del usuario
                            let lastUserQuestion = "";
                            for (let i = messagesHistory.length - 1; i >= 0; i--) {
                                if (messagesHistory[i].role === 'user') {
                                    lastUserQuestion = messagesHistory[i].content;
                                    break;
                                }
                            }

                            // Generate a new unique ID for the next response
                            const structureErrorMsgId = "assistant-structure-error-" + Date.now();

                            // Create a new message for processing
                            messages.addMessage({
                                attrs: {
                                    "data-id": structureErrorMsgId,
                                    "id": structureErrorMsgId
                                },
                                isTitle: false,
                                text: '<p>Procesando tu consulta...</p>',
                                name: assistant.name,
                                cssClass: 'card no-margin-top padding-half',
                                textFooter: footerTemplate,
                                avatar: assistant.avatar,//'https://ui-avatars.com/api/?background=FFF00&name=' + assistant.name.replace(" ", "%20"),
                                type: 'received',
                            }, 'append', true);

                            onMessageAdded($('#' + structureErrorMsgId));
                            //    scrollToBottom();
                            if (window.tempSources && window.tempSources.length > 0) {
                                localStorage.setItem('sources_' + structureErrorMsgId, JSON.stringify(window.tempSources));
                                console.log('Sources guardados en localStorage con clave:', 'sources_' + structureErrorMsgId);
                            }
                            // Añadir un mensaje para que el modelo sepa que hubo un problema con la estructura
                            messagesHistory.push({
                                role: 'user',
                                content: "Respecto a mi pregunta: \"" + lastUserQuestion + "\", ha ocurrido un problema al intentar buscar información adicional. Por favor, responde basándote en tu conocimiento general y menciona cualquier limitación en tu respuesta."
                            });

                            // Llamar a callCompletion para que el modelo elabore la respuesta
                            callCompletion(false, structureErrorMsgId)
                                .then(() => {
                                    processingToolResponse = false;
                                    // Resolver después de que se genere la respuesta
                                    resolve({
                                        status: 'success',
                                        sourcesAdded: true,
                                        message: 'Se ha generado una respuesta por el companion para el caso de error de estructura',
                                        originalResponse: data
                                    });
                                })
                                .catch(error => {
                                    processingToolResponse = false;
                                    console.error("Error en la generación de respuesta para el caso de error de estructura:", error);
                                    // Aún resolver para no interrumpir el flujo
                                    resolve({
                                        status: 'success',
                                        sourcesAdded: true,
                                        message: 'Error en la generación de respuesta para el caso de error de estructura',
                                        originalResponse: data,
                                        error: error
                                    });
                                });
                        }
                    },
                    error: function (xhr, status, error) {
                        console.error("Error en la llamada a la herramienta:", status, error);

                        // Obtener la última pregunta del usuario en caso de error
                        let lastUserQuestion = "";
                        for (let i = messagesHistory.length - 1; i >= 0; i--) {
                            if (messagesHistory[i].role === 'user') {
                                lastUserQuestion = messagesHistory[i].content;
                                break;
                            }
                        }

                        // Generate a new unique ID for the next response
                        const apiErrorMsgId = "assistant-api-error-" + Date.now();

                        // Create a new message for processing
                        messages.addMessage({
                            attrs: {
                                "data-id": apiErrorMsgId,
                                "id": apiErrorMsgId
                            },
                            isTitle: false,
                            text: '<p>Procesando tu consulta...</p>',
                            name: assistant.name,
                            cssClass: 'card no-margin-top padding-half',
                            textFooter: footerTemplate,
                            avatar: assistant.avatar,//'https://ui-avatars.com/api/?background=FFF00&name=' + assistant.name.replace(" ", "%20"),
                            type: 'received',
                        }, 'append', true);
                        if (window.tempSources && window.tempSources.length > 0) {
                            localStorage.setItem('sources_' + apiErrorMsgId, JSON.stringify(window.tempSources));
                            console.log('Sources guardados en localStorage con clave:', 'sources_' + apiErrorMsgId);
                        }
                        onMessageAdded($('#' + apiErrorMsgId));
                        // scrollToBottom();

                        // Añadir un mensaje para que el modelo sepa que hubo un error en la API
                        messagesHistory.push({
                            role: 'user',
                            content: "Respecto a mi pregunta: \"" + lastUserQuestion + "\", ha ocurrido un error al intentar conectar con la fuente de información. Por favor, responde basándote en tu conocimiento general y menciona cualquier limitación en tu respuesta."
                        });

                        // Llamar a callCompletion para que el modelo elabore la respuesta
                        callCompletion(false, apiErrorMsgId)
                            .then(() => {
                                processingToolResponse = false;
                                // Resolver después de que se genere la respuesta
                                resolve({
                                    status: 'success',
                                    sourcesAdded: true,
                                    message: 'Se ha generado una respuesta por el companion para el caso de error de API',
                                    originalError: error
                                });
                            })
                            .catch(compError => {
                                processingToolResponse = false;
                                console.error("Error en la generación de respuesta para el caso de error de API:", compError);
                                // Aún resolver para no interrumpir el flujo
                                resolve({
                                    status: 'success',
                                    sourcesAdded: true,
                                    message: 'Error en la generación de respuesta para el caso de error de API',
                                    originalError: error,
                                    companionError: compError
                                });
                            });
                    }
                });
            });
        };
        let checkScrollPosition = function () {
            if ((pageContent.offsetHeight + pageContent.scrollTop) >= pageContent.scrollHeight - 50) {
                // Ocultar el botón si estamos cerca del final
                scrollToBottomBtn.classList.add('hidden');
            } else {
                // Mostrar el botón en otro caso
                scrollToBottomBtn.classList.remove('hidden');
            }
        }
        let getSourcesByMessageId = function (messageId) {
            const sourcesJson = localStorage.getItem('sources_' + messageId);
            if (sourcesJson) {
                return JSON.parse(sourcesJson).sources;
            }
            return null;
        }
        let stopStreaming = function () {
            // Marcar como no respondiendo independientemente de si hay una solicitud activa
            isResponding = false;
            $update();

            // Intentar abortar la solicitud si existe
            try {
                if (currentStreamingRequest) {
                    // Intentar diferentes métodos para abortar la solicitud
                    if (typeof currentStreamingRequest.abort === 'function') {
                        currentStreamingRequest.abort();
                    } else if (currentStreamingRequest.xhr && typeof currentStreamingRequest.xhr.abort === 'function') {
                        currentStreamingRequest.xhr.abort();
                    } else {
                        console.log("No se pudo abortar directamente, la solicitud no tiene un método abort accesible");
                    }

                    currentStreamingRequest = null;
                }
            } catch (error) {
                console.error("Error al intentar detener la transmisión:", error);
            }

            // Actualizar la UI independientemente de si se pudo abortar la solicitud
            const messageElement = $('.message:last-child .message-text');
            if (messageElement.length) {
                // Añadir una nota al final del mensaje actual
                messageElement.append('<p><em>Response interrupted by user.</em></p>');

                // Eliminar cualquier indicador de "pensando"
                messageElement.find('.thinking-icon').remove();
            }

            // Mostrar notificación al usuario
            $f7.toast.show({
                text: 'response interrupted by user',
                position: 'center',
                closeTimeout: 2000,
            });
        }
// Modified callCompletion function to properly save tool calls in message history
        // Dentro de la función callCompletion, reemplazar la parte que procesa los chunks con esta versión actualizada
        let callCompletion = function (withTool, messageId, stream) {
            withTool = withTool ?? true;
            stream = stream ?? true;
            // Default to "assistant-thinking" if no messageId is provided (for backward compatibility)
            messageId = messageId || "assistant-thinking";
            isResponseInBackground = assistant && chat.mainAssistant.responseOnBackground === true;
            streamingProgress = 0;
            fullStreamingResponse = "";
            console.log(usageData);
            console.log(messagesHistory);
            const cleanMessages = [];

            let payload = {
                stream: stream,
                model: "mistral-small-24B-instruct-2501",//"phi-4",//
                messages: messagesHistory,
                max_tokens: MAX_TOKENS
            }
            if (stream) {
                payload['stream_options'] = {'include_usage': true};
            }

            if (chat.tools && withTool) {
                messagesHistory[0].content = mainSystemMessage.content;
                payload['tool_choice'] = "auto";
                payload['tools'] = chat.tools;
                delete payload['tools']["icon"];
                payload['temperature'] = 0.1
            } else {
                payload['temperature'] = 0
            }
            isResponding = true; // Establecer que está respondiendo
            $update();
            return new Promise((resolve, reject) => {
                let responseData = [];
                let acumulatedText = "";
                let fullResponse = "";
                let isNoTool = false;
                let extractingContent = false;
                let isFunctionCall = false;
                let newMessageId = "";

                // Variables para el nuevo formato de tool_calls
                let isToolCallsFormat = false;
                let accumulatedToolCalls = [];
                let currentToolCall = null;

                // Function to get the message element using the ID
                const getMessageElement = function () {
                    return $('#' + messageId);
                }
                console.log("Response in backgrodun", isResponseInBackground);
                if (isResponseInBackground && !isToolCallsFormat) {
                    const progressHTML = `
    <div class="background-response-container margin-top padding-top">
        <div class="progressbar" id="response-progress">
            <span></span>
        </div>
        <div class="progress-percentage"></div>
    </div>
    <div class="collapsible-container">
        <div class="toggle-button">
            <a href="#" class="toggle-content">
                <i class="fa fa-chevron-down"></i>
            </a>
        </div>
        <div class="response-content" style="display:none">
            <p>Processing response...</p>
        </div>
    </div>
`;

                    getMessageElement().find('.message-text').html(progressHTML);

                    // Inicializar la barra de progreso usando la documentación oficial
                    const progressBarEl = getMessageElement().find('.progressbar')[0];
                    app.progressbar.set(progressBarEl, 0); // Comenzar en 0%

                    // Event listener para el botón de colapsar
                    getMessageElement().find('.toggle-content').on('click', function (e) {
                        e.preventDefault();

                        const container = this.closest('.collapsible-container');
                        const content = container.querySelector('.response-content');
                        const icon = this.querySelector('i');

                        const isVisible = window.getComputedStyle(content).display !== 'none';

                        if (isVisible) {
                            content.style.display = 'none';
                            icon.classList.remove('fa-chevron-up');
                            icon.classList.add('fa-chevron-down');
                        } else {
                            content.style.display = 'block';
                            icon.classList.remove('fa-chevron-down');
                            icon.classList.add('fa-chevron-up');
                        }
                    });
                }

                function updateProgress(value) {
                    if (isResponseInBackground && !isToolCallsFormat) {
                        const progressBarEl = getMessageElement().find('.progressbar')[0];
                        const percentageEl = getMessageElement().find('.progress-percentage')[0];

                        // Actualizar la barra de progreso
                        app.progressbar.set(progressBarEl, value);
                        progressBarEl.setAttribute('data-label', 'Creating step by step guide ' + value + '%');
                        // Actualizar el texto de porcentaje
                        //percentageEl.textContent = value + '%';
                    }
                }


                // Función para procesar y acumular tool calls
                const processToolCalls = function (delta) {
                    if (delta.tool_calls && delta.tool_calls.length > 0) {
                        isToolCallsFormat = true;

                        // Procesar cada tool call en el delta
                        delta.tool_calls.forEach(toolCallDelta => {
                            const index = toolCallDelta.index;

                            // Si no existe el tool call con este índice, crear uno nuevo
                            if (!accumulatedToolCalls[index]) {
                                accumulatedToolCalls[index] = {
                                    index: index,
                                    id: toolCallDelta.id || "",
                                    type: toolCallDelta.type || "function",
                                    function: {
                                        name: "",
                                        arguments: ""
                                    }
                                };
                            }

                            // Actualizar los campos con la nueva información
                            if (toolCallDelta.id) {
                                accumulatedToolCalls[index].id = toolCallDelta.id;
                            }

                            if (toolCallDelta.type) {
                                accumulatedToolCalls[index].type = toolCallDelta.type;
                            }

                            if (toolCallDelta.function) {
                                // Actualizar nombre si viene en el delta
                                if (toolCallDelta.function.name !== null && toolCallDelta.function.name !== undefined) {
                                    accumulatedToolCalls[index].function.name =
                                        (accumulatedToolCalls[index].function.name || "") +
                                        (toolCallDelta.function.name || "");
                                }

                                // Actualizar argumentos si vienen en el delta
                                if (toolCallDelta.function.arguments !== null && toolCallDelta.function.arguments !== undefined) {
                                    accumulatedToolCalls[index].function.arguments =
                                        (accumulatedToolCalls[index].function.arguments || "") +
                                        (toolCallDelta.function.arguments || "");
                                }
                            }

                            // Actualizar currentToolCall para referencia rápida
                            currentToolCall = accumulatedToolCalls[index];
                            isFunctionCall = true;
                        });

                        // Actualizar UI para mostrar que se está procesando una llamada a función
                        let currentToolCallInfo = "";
                        try {
                            // Intentar formatear los tool calls acumulados para mostrarlos
                            currentToolCallInfo = JSON.stringify(accumulatedToolCalls, null, 2);
                            //  getMessageElement().find('.message-text').html('<pre>' + currentToolCallInfo + '</pre>');

                            // IMPORTANTE: Verificar si el tool call parece estar completo
                            // Esto es para ejecutar el tool call sin esperar al finish_reason
                            if (currentToolCall &&
                                currentToolCall.function &&
                                currentToolCall.function.name &&
                                currentToolCall.function.arguments &&
                                currentToolCall.function.arguments.includes('}')) {

                                // Verificar si los argumentos terminan correctamente
                                const args = currentToolCall.function.arguments;
                                // Si los argumentos parecen estar completos (terminan con } y están balanceados)
                                if (args.trim().endsWith('}') && !processingToolResponse) {
                                    // Intentar parsear para ver si el JSON está completo
                                    try {
                                        JSON.parse(args);
                                        console.log("Tool call parece estar completo, procesando:", currentToolCall);
                                        processCompleteToolCall();
                                    } catch (e) {
                                        console.log("Los argumentos parecen estar completos pero el JSON no es válido aún:", e);
                                    }
                                }
                            }
                        } catch (e) {
                            console.error("Error formatting tool calls for UI:", e);
                        }

                        return true;
                    }
                    return false;
                };

                // Función para procesar un tool call completo
                const processCompleteToolCall = function () {
                    if (!currentToolCall || !currentToolCall.function) {
                        console.warn("Tool call incompleto o inválido:", currentToolCall);
                        return false;
                    }

                    // Evitar procesar el mismo tool call varias veces
                    if (processingToolResponse) {
                        console.log("Ya se está procesando un tool call, ignorando duplicado");
                        return false;
                    }

                    try {
                        const toolName = currentToolCall.function.name || "";
                        if (!toolName) {
                            console.warn("Tool call sin nombre de función:", currentToolCall);
                            return false;
                        }

                        let toolParams;

                        try {
                            // Intentar parsear los argumentos como JSON
                            toolParams = JSON.parse(currentToolCall.function.arguments);
                        } catch (e) {
                            console.warn("Error al parsear argumentos de la función, intentando limpiar:", e);
                            // Intentar limpiar y parsear nuevamente
                            const cleanedArgs = currentToolCall.function.arguments.trim()
                                .replace(/^['"]+|['"]+$/g, '') // Quitar comillas al inicio/final
                                .replace(/\\"/g, '"'); // Reemplazar \" por "

                            try {
                                // Si es un string simple, tratarlo como tal
                                if (cleanedArgs.startsWith('{')) {
                                    toolParams = JSON.parse(cleanedArgs);
                                } else {
                                    toolParams = {text: cleanedArgs};
                                }
                            } catch (e2) {
                                console.error("No se pudieron parsear los argumentos después de limpiarlos:", e2);
                                toolParams = {text: currentToolCall.function.arguments};

                                newMessageId = "assistant-thinking-" + Date.now();
                                callCompletion(true, newMessageId, false)
                                    .then(() => {
                                        processingToolResponse = false;
                                        addSourcesToMessage($('#' + newMessageId))
                                        addActionsToMessage($('#' + newMessageId))
                                    })
                                    .catch(error => {
                                        processingToolResponse = false;
                                        console.error("Error en la continuación:", error);
                                    });
                                return;
                                //AQUI llamar a completion
                            }
                        }


                        // Guardar en el historial de mensajes
                        /*  messagesHistory.push({
                              role: 'assistant',
                              content: null,
                              tool_calls: accumulatedToolCalls
                          });*/

                        // Llamar a la herramienta
                        callTool(toolName, toolParams)
                            .then(toolResponse => {
                                console.log("Respuesta de la herramienta procesada:", toolResponse);
                                $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                                // Si se añadieron sources, llamar a callCompletion nuevamente
                                if (toolResponse.sourcesAdded) {
                                    console.log("Continuando la conversación con los sources añadidos");

                                    // Generar un nuevo ID único para la siguiente respuesta
                                    newMessageId = "assistant-thinking-" + Date.now();

                                    // Crear un nuevo mensaje para la respuesta continuada
                                    messages.addMessage({
                                        attrs: {
                                            "data-id": newMessageId,
                                            "id": newMessageId
                                        },
                                        isTitle: false,
                                        text: '<p>Processing retrieved information...</p>',
                                        textFooter: footerTemplate,
                                        name: assistant.name,
                                        cssClass: 'card no-margin-top padding-half',
                                        avatar: assistant.avatar,//'https://ui-avatars.com/api/?background=FFF00&name=' + assistant.name.replace(" ", "%20"),
                                        type: 'received',
                                    }, 'append', true);

                                    if (window.tempSources && window.tempSources.length > 0) {
                                        const sourceArray = {
                                            "sources": window.tempSources,
                                            "params": toolParams
                                        }
                                        localStorage.setItem('sources_' + newMessageId, JSON.stringify(sourceArray));
                                        console.log('Sources guardados en localStorage con clave:', 'sources_' + newMessageId);
                                    }

                                    onMessageAdded($('#' + newMessageId));
                                    //  scrollToBottom();

                                    // Llamar a callCompletion nuevamente pero con un nuevo mensaje
                                    callCompletion(false, newMessageId)
                                        .then(() => {
                                            processingToolResponse = false;
                                            addSourcesToMessage($('#' + newMessageId))
                                            addActionsToMessage($('#' + newMessageId));
                                        })
                                        .catch(error => {
                                            processingToolResponse = false;
                                            console.error("Error en la continuación:", error);
                                        });
                                } else {
                                    // Si no se añadieron sources, restablecer el flag
                                    processingToolResponse = false;
                                }
                            })
                            .catch(error => {
                                processingToolResponse = false;
                                console.error("Error al llamar a la herramienta:", error);
                            });

                        return true;
                    } catch (error) {
                        console.error("Error al procesar tool call completo:", error);
                        processingToolResponse = false;
                        return false;
                    }
                };

                try {
                    // Configurar la solicitud a través de Framework7
                    const requestConfig = {
                        url: window.config.completion.url,
                        method: 'POST',
                        data: payload,
                        contentType: 'application/json',
                        dataType: 'text',
                        headers: {
                            'Authorization': `Bearer ${window.config.completion.apiKey}`,
                            'Accept': 'text/event-stream'
                        },
                        xhrFields: {
                            onprogress: function (e) {
                                if (!isResponding) {
                                    if (currentStreamingRequest &&
                                        currentStreamingRequest.xhr &&
                                        typeof currentStreamingRequest.xhr.abort === 'function') {
                                        currentStreamingRequest.xhr.abort();
                                    }
                                    return;
                                }
                                // Get new text since last update
                                const newText = e.target.responseText.substring(acumulatedText.length);
                                acumulatedText = e.target.responseText;

                                // Process new lines
                                const lines = newText.split('\n');
                                let displayContent = '';
                                for (const line of lines) {
                                    if (line.startsWith('data: ')) {
                                        try {
                                            // Extract JSON data
                                            const jsonData = line.substring(6);
                                            if (jsonData.trim() === '') continue;

                                            // Parse JSON
                                            const parsedData = JSON.parse(jsonData);
                                            responseData.push(parsedData);

                                            // Comprobar el nuevo formato de tool_calls si existe
                                            if (parsedData.choices &&
                                                parsedData.choices.length > 0 &&
                                                parsedData.choices[0].delta) {

                                                const delta = parsedData.choices[0].delta;

                                                // Verificar si este delta contiene tool_calls
                                                if (processToolCalls(delta)) {
                                                    // Ya se ha procesado el tool_call, continuar al siguiente chunk
                                                    continue;
                                                }

                                                // Procesar delta.content si existe (formato tradicional)
                                                if (delta.content) {
                                                    const content = delta.content;
                                                    fullResponse += content;
                                                    fullStreamingResponse += content;

                                                    // Actualizar la barra de progreso
                                                    if (isResponseInBackground && !isToolCallsFormat) {
                                                        streamingProgress += 1;
                                                        // Calcular porcentaje (suponiendo respuesta promedio de 1000 tokens)
                                                        const percentage = Math.min(Math.round((streamingProgress / 10)), 99);
                                                        updateProgress(percentage)

                                                        /* getMessageElement().find('.progress-bar').css('width', percentage + '%');
                                                     getMessageElement().find('.progress-percentage').text(percentage + '%');*/
                                                        // Actualizar el contenido oculto
                                                        getMessageElement().find('.response-content').html(md.render(preprocessMarkdown(fullStreamingResponse) + '<span class="thinking-icon">' + assistant.thinkIcon + '</span>'));
                                                    } else {
                                                        // Comportamiento normal
                                                        getMessageElement().find('.message-text').html(md.render(preprocessMarkdown(fullResponse) + '<span class="thinking-icon">' + assistant.thinkIcon + '</span>'));
                                                    }
                                                }
                                            }
                                            checkScrollPosition();
                                            // Check if this is the last chunk
                                            if (parsedData.choices &&
                                                parsedData.choices.length > 0 &&
                                                parsedData.choices[0].finish_reason !== null) {

                                                if (isResponseInBackground && !isToolCallsFormat) {
                                                    updateProgress(100)
                                                    /*getMessageElement().find('.progress-bar').css('width', '100%');
                                                getMessageElement().find('.progress-percentage').text('100%');*/
                                                }

                                                // Verificar si debemos procesar un tool call completo
                                                if (isToolCallsFormat && currentToolCall) {
                                                    processCompleteToolCall();
                                                }
                                                // Si es contenido normal sin tool_calls
                                                else if (!isToolCallsFormat && !withTool) {
                                                    messagesHistory.push({
                                                        role: 'assistant',
                                                        content: fullResponse,
                                                    });
                                                    console.log("añadiendo ASSISTANT con tool");
                                                }
                                                if (isResponseInBackground && !isToolCallsFormat) {
                                                    // Actualizar a 100%
                                                    $f7.progressbar.set(getMessageElement().find('.progressbar')[0], 100);
                                                    getMessageElement().find('.progress-percentage').text('');//100% Completado');

                                                    // Actualizar el contenido final
                                                    getMessageElement().find('.response-content').html(md.render(preprocessMarkdown(fullResponse)));

                                                    // Asegurarnos de que la respuesta se agregue al historial
                                                    /*  if (!messagesHistory.some(msg =>
                                                      msg.role === 'assistant' && msg.content === fullResponse)) {
                                                      messagesHistory.push({
                                                          role: 'assistant',
                                                          content: fullResponse,
                                                      });
                                                      console.log("Añadiendo ASSISTANT en modo background");
                                                  }*/

                                                    if (chat.mainAssistant.onResponseComplete !== null && chat.mainAssistant.onResponseComplete !== undefined) {
                                                        try {
                                                            eval(chat.mainAssistant.onResponseComplete);

                                                        } catch (error) {
                                                            console.error("Error al crear o ejecutar la función:", error);
                                                        }
                                                    }
                                                }
                                                // Manejar el contenido según lo detectado
                                                if (chat.tools && withTool && !isToolCallsFormat) {
                                                    if (!processingToolResponse && !isToolCallsFormat && (isFunctionCall || (!isNoTool && !extractingContent))) {
                                                        // Para tool en formato antiguo, mantener el JSON completo
                                                        console.log("Mostrando JSON de herramienta al finalizar");
                                                        //  getMessageElement().find('.message-text').html('<pre>' + fullResponse + '</pre>');
                                                        messagesHistory.push({
                                                            role: 'assistant',
                                                            content: fullResponse
                                                        });
                                                    }
                                                }

                                                // Generate a unique completed ID
                                                const completedId = "message-completed-" + Date.now();

                                                // Use ID selector to get only the current message
                                                if (isNoTool && !isToolCallsFormat) {
                                                    getMessageElement().attr("id", completedId).attr('data-id', completedId);
                                                }
                                                //     addSourcesToMessage($('#' + thinkingMsgId));
                                                addActionsToMessage($('#' + completedId))
                                                console.log("Transmisión SSE completada");

                                                //  scrollToBottom();
                                            }

                                        } catch (error) {
                                            console.error("Error al procesar línea SSE:", error, line);
                                        }
                                    }
                                }
                            }
                        },
                        success: function (data) {
                            console.log("Petición completada con éxito");
                            $(".thinking-icon").remove();
                            currentStreamingRequest = null;
                            isResponding = false;
                            $update();
                            $(".reference").each(function () {
                                $(this).off('click');
                                $(this).on("click", function (e) {

                                    openPopoverText(e);
                                });

                                // Añadir estilo inline al <li> padre si existe
                                const $parentLi = $(this).closest('li');
                                if ($parentLi.length) {
                                    $parentLi.css('list-style-type', 'none');
                                }
                            });
                            // Extraer información de uso de tokens


                            // Buscar información de uso de tokens en diferentes formatos de respuesta
                            if (typeof data === 'string') {
                                const lines = data.split('\n');
                                for (const line of lines) {
                                    if (line.startsWith('data: ')) {
                                        try {
                                            const jsonData = line.substring(6).trim();
                                            if (!jsonData || jsonData === '') continue;

                                            const chunkData = JSON.parse(jsonData);
                                            if (chunkData.usage) {
                                                usageData = chunkData.usage;
                                            }
                                        } catch (e) {
                                            console.error("Error parsing chunk:", e);
                                        }
                                    }
                                }
                            } else if (data && data.usage) {
                                usageData = data.usage;
                            } else if (responseData && responseData.length > 0) {
                                const lastChunk = responseData[responseData.length - 0];
                                if (lastChunk && lastChunk.usage) {
                                    usageData = lastChunk.usage;
                                }
                            }

                            // Si encontramos información de uso de tokens
                            if (usageData) {
                                console.log("%c === TOKEN USAGE INFORMATION ===", "color: blue; font-weight: bold");
                                console.log(`Prompt tokens: ${usageData.prompt_tokens}`);
                                console.log(`Completion tokens: ${usageData.completion_tokens}`);
                                console.log(`Total tokens: ${usageData.total_tokens}`);
     // Verificar si necesitamos optimizar la conversación
                                setTimeout(async () => {
                                    try {
                                        const result = await optimizeConversationInBackground(messagesHistory, {
                                            $f7,
                                            config: window.config,
                                            tokenLimit: TOKEN_LIMIT,
                                            summaryModel: SUMMARY_MODEL,
                                            maxTokens: MAX_TOKENS,
                                            cleanSimbaDocuments
                                        });

                                        if (result && result.optimized) {
                                            console.log(`🎉 Optimized: Saved ${result.tokenReduction} tokens!`);
                                        } else {
                                            console.log("📊 No optimization needed");
                                        }
                                    } catch (error) {
                                        console.error("Optimization failed:", error);
                                    }
                                }, 1000);
                            }
                            addCodeHeaders();
                            addActionsToMessage(getMessageElement());
                            // document.documentElement.style.setProperty('--message-height', `auto`);
                            $('table').each(function (index) {
                                // Add data-table class as before
                                this.classList.add('data-table');

                                // Create a unique ID for this table if it doesn't have one
                                const tableId = this.id || 'data-table-' + Date.now();// + '-' + index;
                                this.id = tableId;

                                // Create container element
                                const container = document.createElement('div');
                                container.className = 'table-container margin-bottom';
                                container.style.overflow = 'overlay';
                                container.id = 'container-' + tableId;

                                // Create export button
                                const exportButton = document.createElement('span');
                                exportButton.className = 'export-csv-button link float-right margin-bottom-half margin-right-half';
                                exportButton.innerHTML = '<i class="fa fa-download"></i> CSV';
                                exportButton.dataset.table = tableId;
                                exportButton.addEventListener('click', function (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    const targetTableId = this.dataset.table;
                                    exportTableToCSV(document.getElementById(targetTableId));
                                });

                                // Insert our new elements
                                const parent = this.parentNode;
                                parent.insertBefore(container, this);
                                container.appendChild(exportButton);
                                container.appendChild(this);
                            });
                            if (isResponseInBackground && !isToolCallsFormat) {
                                getMessageElement().find('.progress-bar').css('width', '100%');
                                getMessageElement().find('.progress-percentage').text('');//100% Completado');

                                // Verificar que la respuesta esté en el historial
                                if (!messagesHistory.some(msg =>
                                    msg.role === 'assistant' && msg.content === fullResponse)) {
                                    messagesHistory.push({
                                        role: 'assistant',
                                        content: fullResponse,
                                    });
                                    console.log("Añadiendo ASSISTANT en success handler (modo background)");
                                }
                            }
                            // Check if data is a string and try to parse it
                            let parsedData;
                            if (typeof data === 'string') {
                                try {
                                    parsedData = JSON.parse(data);
                                } catch (e) {
                                    console.log("Data is not JSON or is already parsed");
                                    parsedData = data;
                                }
                            } else {
                                parsedData = data;
                            }

                            // Handle case where data comes in full completion format (not streaming)
                            if (parsedData &&
                                parsedData.choices &&
                                parsedData.choices.length > 0 &&
                                parsedData.choices[0].message &&
                                parsedData.choices[0].message.tool_calls &&
                                parsedData.choices[0].message.tool_calls.length > 0) {

                                console.log("Detected full completion with tool_calls");

                                // Extract tool call data
                                const toolCall = parsedData.choices[0].message.tool_calls[0];
                                const toolName = toolCall.function.name;
                                let toolParams;

                                try {
                                    toolParams = JSON.parse(toolCall.function.arguments);
                                } catch (e) {
                                    console.warn("Error parsing tool arguments:", e);
                                    const cleanedArgs = toolCall.function.arguments.trim()
                                        .replace(/^['"]+|['"]+$/g, '') // Remove quotes at beginning/end
                                        .replace(/\\"/g, '"'); // Replace \" with "

                                    try {
                                        toolParams = JSON.parse(cleanedArgs);
                                    } catch (e2) {
                                        console.error("Could not parse arguments after cleaning:", e2);
                                        toolParams = {text: toolCall.function.arguments};
                                    }
                                }

                                callTool(toolName, toolParams)
                                    .then(toolResponse => {
                                        console.log("Tool response processed:", toolResponse);
                                        $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                                        // If sources were added, call callCompletion again
                                        if (toolResponse.sourcesAdded) {
                                            console.log("Continuing conversation with added sources");

                                            // Generate a new unique ID for the next response
                                            newMessageId = "assistant-thinking-" + Date.now();

                                            // Create a new message for the continued response
                                            messages.addMessage({
                                                attrs: {
                                                    "data-id": newMessageId,
                                                    "id": newMessageId
                                                },
                                                isTitle: false,
                                                text: '<p>Processing retrieved information...</p>',
                                                textFooter: footerTemplate,
                                                name: assistant.name,
                                                cssClass: 'card no-margin-top padding-half',
                                                avatar: assistant.avatar,//'https://ui-avatars.com/api/?background=FFF00&name=' + assistant.name.replace(" ", "%20"),
                                                type: 'received',
                                            }, 'append', true);

                                            if (window.tempSources && window.tempSources.length > 0) {
                                                const sourceArray = {
                                                    "sources": window.tempSources,
                                                    "params": toolParams
                                                }
                                                localStorage.setItem('sources_' + newMessageId, JSON.stringify(sourceArray));
                                                console.log('Sources saved in localStorage with key:', 'sources_' + newMessageId);
                                            }

                                            onMessageAdded($('#' + newMessageId));
                                            // scrollToBottom();

                                            // Call callCompletion again but with a new message
                                            callCompletion(false, newMessageId)
                                                .then(() => {
                                                    processingToolResponse = false;
                                                    addSourcesToMessage($('#' + newMessageId))
                                                    addActionsToMessage($('#' + newMessageId));
                                                })
                                                .catch(error => {
                                                    processingToolResponse = false;
                                                    console.error("Error in continuation:", error);
                                                });
                                        } else {
                                            // If no sources were added, reset the flag
                                            processingToolResponse = false;
                                        }
                                    })
                                    .catch(error => {
                                        processingToolResponse = false;
                                        console.error("Error calling tool:", error);
                                    });
                            } else {
                                // Original success handling for streaming responses
                                // Determining what to return in the promise
                                let responseContent;

                                if (chat.tools) {
                                    if (isToolCallsFormat) {
                                        // For tool_calls in new format
                                        responseContent = JSON.stringify(accumulatedToolCalls, null, 2);
                                    } else {
                                        // For other cases, return complete JSON
                                        responseContent = fullResponse;
                                    }
                                } else {
                                    // If no tools, return the complete response
                                    responseContent = fullResponse;
                                }

                                // Don't modify the system message
                                messagesHistory[0].content = mainSystemMessage.content;

                                resolve({
                                    chunks: responseData,
                                    fullResponse: fullResponse,
                                    content: responseContent,
                                    isNoTool: isNoTool,
                                    processingTool: processingToolResponse,
                                    toolCalls: isToolCallsFormat ? accumulatedToolCalls : null
                                });
                            }
                        },
                        error: function (xhr, status, error) {
                            // Manejar el caso de una cancelación iniciada por el usuario
                            if (status === 'abort') {
                                console.log("Petición cancelada por el usuario");
                                resolve({
                                    status: 'aborted',
                                    message: 'Respuesta interrumpida por el usuario'
                                });
                            } else {
                                $f7.toast.show({
                                    text: 'Unable to connect to completion service.',
                                    position: 'center',
                                    closeTimeout: 3000,
                                    cssClass: 'color-red'
                                });

                                if (isResponseInBackground) {
                                    getMessageElement().find('.progress-container').addClass('error');
                                    getMessageElement().find('.progress-percentage').text('Error');
                                }
                            }
                            reject(error);
                        }
                    }
                    currentStreamingRequest = $f7.request(requestConfig);
                    // Añadir un manejador de eventos para detectar si el botón de stop se presiona
                    // (sólo como respaldo si el método abort() no funciona directamente)
                    window.addEventListener('completion_stop_requested', function handleStop() {
                        if (currentStreamingRequest &&
                            currentStreamingRequest.xhr &&
                            typeof currentStreamingRequest.xhr.abort === 'function') {
                            currentStreamingRequest.xhr.abort();
                        }
                        window.removeEventListener('completion_stop_requested', handleStop);
                    }, {once: true});
                } catch (initError) {
                    // Capturar errores durante la inicialización de la solicitud
                    console.error("Error al iniciar la solicitud:", initError);
                    isResponding = false;
                    $update();

                    // Mostrar error al usuario
                    $f7.toast.show({
                        text: 'Unable to connect to completion service.',
                        position: 'center',
                        closeTimeout: 3000,
                        cssClass: 'color-red'
                    });

                    reject(initError);

                }
            });
        }
        let setPrompt = function (myPrompt, isSelection) {
            isSelection = isSelection ?? 0;
            $("#prompt").val(myPrompt);
            prompt = myPrompt;
            if (isSelection) {
                prompt = prompt + ': ' + selectedText;
            }
            sendPrompt();
        }
        let sendPrompt = function () {
            if ((prompt && prompt.length && myDevice) || !chat.mainAssistant.deviceSelector) {

                if (notFinishedMessage == '') {
                    response = '';
                    $update();

                    // User message with unique ID
                    const userMsgId = "user-msg-" + Date.now();
                    messages.addMessage({
                            attrs: {
                                "data-id": userMsgId,
                                "id": userMsgId
                            },
                            isTitle: false,
                            text: '<p class="no-margin-top float-left">' + prompt + '</p>',
                            textHeader: '<div class="margin-bottom margin-left-half padding-bottom" id="header-' + userMsgId + '"></div>',//<a href="#" id="more_options_prompt" class="link more-options icon-only color-gray"><i class="icon f7-icons font-size-12 text-color-gray">ellipsis_vertical</i></a>',
                            name: 'Alfredo García',
                            cssClass: 'sent card no-margin-top padding-half',
                            type: 'received',
                            avatar: 'https://ui-avatars.com/api/?name=Alfredo%20García',
                            textFooter: footerTemplate

                        }
                        , 'append', true);

                    /*   messagesHistory.push({
                           role: 'user',
                           content: prompt,
                       });*/

                    ///////////////////////////////DROPZONE////////////////////////////////////////
                    // Si hay archivos subidos con texto extraído, añadir ese contenido al mensaje
                    let extractedContents = "";
                    if (window.myFileDropzone) {
                        extractedContents = window.myFileDropzone.getCombinedExtractedText();
                    }
                    window.myFileDropzone.renderFileItems('header-' + userMsgId);

// Añadir el contenido extraído al mensaje si existe
                    let messageContent = prompt;
                    if (extractedContents) {
                        // Se inyecta el contenido oculto al modelo, pero no se muestra en UI
                        messageContent = extractedContents + "\n\n" + prompt;
                    }

// Usar messageContent en lugar de prompt al añadir el mensaje a la historia
                    messagesHistory.push({
                        role: 'user',
                        content: messageContent,
                    });

                    // Limpiar los archivos después de enviar
                    if (window.myFileDropzone) {
                        window.myFileDropzone.clearFiles();
                    }
                    ///////////////////////////////DROPZONE////////////////////////////////////////
                    onMessageAdded($('#' + userMsgId));
                    scrollToBottom();

                    if (navigator.onLine) {
                        // Create assistant thinking message with unique ID
                        const thinkingMsgId = "assistant-thinking-" + Date.now();
                        messages.addMessage({
                            attrs: {"data-id": thinkingMsgId, "id": thinkingMsgId},
                            isTitle: false,
                            text: '<p><span class="thinking-icon">' + assistant.thinkIcon + '</span></p>',
                            name: assistant.name,
                            cssClass: 'card no-margin-top padding-half',
                            textFooter: footerTemplate,
                            type: 'received',
                            avatar: assistant.avatar,//'https://ui-avatars.com/api/?background=FFF00&name=' + assistant.name.replace(" ", "%20"),
                        }, 'append', true);
                        setDynamicHeight(messagesHistory);

                        onMessageAdded($('#' + thinkingMsgId));
                        //     addSourcesToMessage($('#' + thinkingMsgId));
                        addActionsToMessage($('#' + thinkingMsgId))
                        if (!window.config.completion.url || !window.config.completion.apiKey) {
                            console.log('Configuración incompleta para API de completions.');
                            return;
                        }

                        //   $('input[name="chip-selectable-device"][value="ARMS"]').prop('checked', true).trigger('change');
                        const radioButtons = $el.value.find('input[name="chip-selectable-device"]');

                        // Iterar sobre los elementos encontrados
                        radioButtons.forEach(radio => {
                            if (radio.value === myDevice) {
                                radio.checked = true;

                                // Disparar evento change
                                const event = new Event('change');
                                radio.dispatchEvent(event);
                            }
                        });
                        $el.value.find('.messagebar-chat textarea')[0].value = '';

                        $el.value.find('#prompt')[0].focus();
                        scrollToBottom();

                        // Pass the unique ID to callCompletion
                        callCompletion(true, thinkingMsgId);
                    }
                    // console.log("seteando device"+$el.value.find('input[name="chip-selectable-device"]'))
                    //     console.log($el.value.find('input[name="chip-selectable-device"]'))
                }
            } else {
                $f7.toast.show({
                    text: 'Please select a Training Device before submit a query.',
                    //cssClass: 'color-orange',
                    position: 'center',
                    horizontalPosition: 'center'

                });
            }
        }
        let handleDeviceSelection = function (e) {
            myDevice = e.target.value;
            $update();
            document.getElementById('prompt').focus();

        }

        let handleOpenDeviceSelection = function (e) {
            myDevice = null;
            prompt = null;
            $update();
        }
        let handlePromptTextArea = function (e) {
            var value = e.target.value;
            // Cambios en el icono según el contenido de 'value'
            if (value.length > 0) {
                prompt = value;
                // Cambia el icono a 'send'
            } else {
                prompt = null;
                // Cambia el icono a 'mic'
            }

            // Verifica si la tecla presionada es Enter y no se presionó la tecla Shift
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Previene el comportamiento por defecto del Enter
                sendPrompt(); // Llama a la función sendPrompt
            }

            $update();
        }
        let handleKeyDown = function (e) {
            // Verifica si la tecla presionada es Enter
            // Permite crear nueva línea con Shift+Enter
            if (e.key === 'Enter' && e.shiftKey) {
                // No hacer nada, permitir el comportamiento predeterminado
                return;
            }

            // Si es solo Enter (sin Shift), enviar el mensaje
            if (e.key === 'Enter' && !e.shiftKey && !isSuggestionsVisible) {
                e.preventDefault(); // Previene el comportamiento por defecto
                sendPrompt(); // Llama a la función sendPrompt
            }
        }
        let initializeMessagebar = function () {
            messagebar = $f7.messagebar.create({
                el: $el.value.find('.messagebar-chat'),
                textareaEl: $el.value.find('.messagebar-chat textarea')
            });
        }

        let initializeMessages = function () {
            var self = this;
            messages = $f7.messages.create({
                el: $el.value.find('.messages'),
                scrollMessages: true,
                autoLayout: true,
                scrollMessagesOnEdge: true,
                firstMessageRule: function (message, previousMessage, nextMessage) {

                    if (message != undefined) {

                        if (message.isTitle) {
                            return false;
                        }

                        if (!previousMessage || previousMessage.type !== message.type || previousMessage.name !== message.name) {
                            return true;
                        }

                    }

                    return false;
                },

                lastMessageRule: function (message, previousMessage, nextMessage) {
                    //    console.log(message)
                    if (message != undefined) {
                        if (message.isTitle) {
                            return false;
                        }
                        if (!nextMessage || nextMessage.type !== message.type || nextMessage.name !== message.name) {
                            return true;
                        }
                    }

                    return false;
                },

                tailMessageRule: function (message, previousMessage, nextMessage) {
                    if (message != undefined) {
                        if (message.isTitle) {
                            return false;
                        }
                        if (!nextMessage || nextMessage.type !== message.type || nextMessage.name !== message.name) {
                            return true;
                        }
                    }
                    return false;
                }
            });


        }

        let initializePopupTicket = function () {
            popupTicket = $f7.popup.create({
                el: $el.value.find('#popup-ticket')
            });
        }

        let openPopupTicket = function () {
            popupTicket.open();
        }

        let closePopupTicket = function (created) {
            if (assistant){
            created = created || false;
            if (created) {
                formTicketValidator.resetForm();
            } else {
                let newMessageId = "assistant-thinking-" + Date.now();

                // Crear un nuevo mensaje para la respuesta continuada

                $(".shimmer-text-fast").removeClass("shimmer-text-fast")
                message = "<em class='margin-top-half'>Support ticket creation canceled by user</em>"
                messages.addMessage({
                    attrs: {
                        "data-id": newMessageId,
                        "id": newMessageId
                    },
                    isTitle: false,
                    text: message,
                    textFooter: footerTemplate,
                    cssClass: 'card no-margin-top padding-half',
                    avatar: assistant.avatar,//'https://ui-avatars.com/api/?background=FFF00&name=' + assistant.name.replace(" ", "%20"),
                    type: 'received',
                }, 'append', true);

                messagesHistory.push({
                    role: 'assistant',
                    content: message,
                })
            }
            popupTicket.close();
            }
        }

        let initializeFormValidator = function () {
            formTicketValidator = jQuery($el.value.find('form[name=ticket]')).validate({
                rules: {
                    problem_title: {
                        required: true
                    },
                    problem_description: {
                        required: true,
                    },
                    device: {
                        required: true
                    }
                },
                messages: {
                    title: {
                        required: 'Please enter a quick description of the issue.'
                    },
                    description: {
                        required: 'Please enter a full description and details of the issue.',
                    },
                    device: {
                        required: 'Please enter the simulator/device.'
                    }
                },
                submitHandler: function (form) {

                    const payload = {
                        name: 'action_open_support_ticket',
                        params: $f7.form.convertToData(form),
                        chat: chat.guid
                    };

                    function buildServiceRequestMessage(response) {
                        // Extraer los datos relevantes del JSON de respuesta
                        const {ticket_id, guid, url, created_at} = response;

                        // Formatear la fecha de manera más legible
                        const date = new Date(created_at);
                        const formattedDate = date.toLocaleString('en-US', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });

                        // Construir el mensaje en formato Markdown
                        const markdownMessage = `
## Service Request Created Successfully

Your service request has been submitted and assigned the following ID:

**${ticket_id}**

Created on: ${formattedDate}

You can <a href="#" onclick="viewDocument('${url}','${ticket_id}')" class="link icon-only" target="_blank">click here to view details</a> or track the progress of your request.

Thank you for your patience. Our support team will review your request shortly.
`;

                        return markdownMessage;
                    }

                    $f7.request({
                        url: window.config.api_methods.call_tool,
                        method: 'POST',
                        data: payload,
                        contentType: 'application/json',
                        dataType: 'json',
                        headers: {
                            'x-auth-token': window.config.token
                        },
                        success: function (data, status, xhr) {
                            console.log("Llamada a herramienta completada con éxito:", data);
                            if (data && data.data && data.data["tool_domain"] == 'action') {

                                $f7.toast.show({
                                    text: 'Thank you for open a Service Request. We will get back to you soon.',
                                    cssClass: 'color-green'
                                });
                                console.log("Ticket creado", data);

                                let newMessageId = "assistant-thinking-" + Date.now();

                                // Crear un nuevo mensaje para la respuesta continuada

                                $(".shimmer-text-fast").removeClass("shimmer-text-fast")
                                message = md.render(buildServiceRequestMessage(data.data));
                                messages.addMessage({
                                    attrs: {
                                        "data-id": newMessageId,
                                        "id": newMessageId
                                    },
                                    isTitle: false,
                                    text: message,
                                    textFooter: footerTemplate,
                                    cssClass: 'card no-margin-top padding-half',
                                    avatar: assistant.avatar,//'https://ui-avatars.com/api/?background=FFF00&name=' + assistant.name.replace(" ", "%20"),
                                    type: 'received',
                                }, 'append', true);

                                messagesHistory.push({
                                    role: 'assistant',
                                    content: message,
                                })
                                closePopupTicket(true);
                                return
                            }
                        }
                    });
                }
            });
        }
        let initPopoverSelection = function () {
            popoverSelection = $f7.popover.create({
                el: $el.value.find('#popover-selection')
            });

            document.addEventListener('contextmenu', function (event) {
                const selection = window.getSelection();
                console.log('1. Texto seleccionado:', selection.toString().trim());

                if (selection.toString().trim().length > 0) {
                    event.preventDefault();
                    selectedText = selection.toString().trim();
                    let targetElement = event.target;
                    console.log('2. Elemento target:', targetElement);

                    let isMessageText = false;
                    let isAlreadyHighlighted = false;

                    // Comprobar si el elemento ya está resaltado
                    if (targetElement.classList && (targetElement.classList.contains('highlighted-text') ||
                        targetElement.classList.contains('reporting-highlight'))) {
                        isAlreadyHighlighted = true;
                        console.log('3. Ya está highlighted, eliminando...');

                        // Obtener el ID del elemento que se va a eliminar
                        const elementId = targetElement.id;

                        // Eliminar del objeto highlights si existe
                        if (elementId && highlights[elementId]) {
                            delete highlights[elementId];
                            console.log('Elemento eliminado del objeto highlights:', elementId);
                        }

                        // Eliminar el resaltado existente del DOM
                        const parent = targetElement.parentNode;
                        parent.insertBefore(document.createTextNode(targetElement.textContent), targetElement);
                        parent.removeChild(targetElement);

                        // Actualizar la vista
                        $update();

                        // Limpiar la selección y terminar
                        selection.removeAllRanges();

                        return;
                    }

                    console.log('3. ¿Ya highlighted?', isAlreadyHighlighted);

                    // Comprobar si el elemento o alguno de sus padres tiene la clase message-text
                    let currentElement = targetElement;
                    while (currentElement && currentElement !== document.body) {
                        console.log('4. Checking element:', currentElement, 'classes:', currentElement.classList);

                        if (currentElement.classList && currentElement.classList.contains('message-text')) {
                            isMessageText = true;
                            console.log('5. Encontró message-text!');
                            break;
                        }
                        if (currentElement.classList && currentElement.classList.contains('highlighted-text')) {
                            isAlreadyHighlighted = true;
                            break;
                        }
                        currentElement = currentElement.parentElement;
                    }

                    console.log('6. isMessageText final:', isMessageText);
                    console.log('7. isAlreadyHighlighted final:', isAlreadyHighlighted);

                    if (isMessageText && !isAlreadyHighlighted) {
                        console.log('8. Procediendo a crear highlight...');

                        try {
                            const range = selection.getRangeAt(0);
                            console.log('9. Range obtenido:', range);

                            // Marcar físicamente el texto seleccionado en azul (color original)
                            const highlightSpan = document.createElement('span');
                            highlightSpan.style.backgroundColor = '#415c8d';
                            highlightSpan.style.color = 'black';
                            highlightSpan.className = 'highlighted-text';
                            const myId = 'highlight_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                            highlightSpan.id = myId;

                            console.log('10. Span creado con ID:', myId);

                            // Intentar surroundContents, si falla usar alternativa
                            try {
                                range.surroundContents(highlightSpan);
                                console.log('11. surroundContents exitoso');
                            } catch (e) {
                                console.log('11. surroundContents falló, usando alternativa:', e);
                                // Alternativa: extraer contenido y reemplazar
                                const contents = range.extractContents();
                                highlightSpan.appendChild(contents);
                                range.insertNode(highlightSpan);
                            }

                            console.log('12. Highlight aplicado');

                            // Obtener posición del rectángulo del span recién creado
                            const rect = highlightSpan.getBoundingClientRect();
                            console.log('13. Rectángulo obtenido:', rect);

                            // Crear un elemento temporal para usar como target del popover
                            const tempTarget = document.createElement('div');
                            tempTarget.style.position = 'absolute';
                            tempTarget.style.left = rect.left + 'px';
                            tempTarget.style.top = rect.bottom + 'px';
                            tempTarget.style.width = '1px';
                            tempTarget.style.height = '1px';
                            tempTarget.style.pointerEvents = 'none';
                            tempTarget.id = 'temp-popover-target';
                            document.body.appendChild(tempTarget);

                            console.log('14. Elemento temporal creado');

                            // Guardar el texto seleccionado como atributo en el popover
                            const popoverEl = document.getElementById('popover-selection');
                            if (popoverEl) {
                                popoverEl.setAttribute('data-selected-text', selectedText);
                                popoverEl.setAttribute('data-selected-id', myId);
                                console.log('15. Atributos del popover establecidos');
                            } else {
                                console.log('15. ERROR: No se encontró el elemento popover-selection');
                            }

                            // Mostrar el popover
                            popoverEl.addEventListener('popover:close', () => {
                                console.log('16. Popover cerrado');
                                setTimeout(function () {
                                    app.$("#popover-selection").find('.input-clear-button').trigger("click")
                                }, 1000);
                                clearHighlights();
                            });

                            console.log('17. Intentando abrir popover...');
                            if (popoverSelection) {
                                popoverSelection.open('#temp-popover-target');
                                console.log('18. Popover abierto');
                            } else {
                                console.log('18. ERROR: popoverSelection no existe');
                            }

                            // Limpiar el elemento temporal
                            setTimeout(() => {
                                if (document.getElementById('temp-popover-target')) {
                                    document.body.removeChild(tempTarget);
                                    console.log('19. Elemento temporal eliminado');
                                }
                            }, 100);

                        } catch (error) {
                            console.log('ERROR en el proceso de highlighting:', error);
                        }
                    } else {
                        console.log('8. NO se cumplieron las condiciones para mostrar popover');
                    }
                } else {
                    console.log('1. No hay texto seleccionado o está vacío');
                }
            });
        }

        function copyToClipboard() {
            // Obtener el texto seleccionado desde el atributo del popover
            const popoverEl = document.getElementById('popover-selection');
            const selectedText = popoverEl.getAttribute('data-selected-text');

            if (selectedText) {
                // Método moderno (preferido)
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(selectedText).then(() => {
                        app.toast.create({
                            text: 'Text copied to clipboard',
                            position: 'center',
                            closeTimeout: 1500,
                        }).open();
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        fallbackCopyTextToClipboard(selectedText);
                    });
                } else {
                    // Método fallback para navegadores más antiguos
                    fallbackCopyTextToClipboard(selectedText);
                }
            }
        }

// Función fallback para navegadores que no soportan navigator.clipboard
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;

            // Evitar scroll al final de la página
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    app.toast.create({
                        text: 'Text copied to clipboard',
                        position: 'center',
                        closeTimeout: 1500,
                    }).open();
                }
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
                app.toast.create({
                    text: 'Failed to copy text',
                    position: 'center',
                    closeTimeout: 1500,
                }).open();
            }

            document.body.removeChild(textArea);
        }
// Función para el botón "Highlight for reporting"
        function highlightForReporting() {
            // Obtener el ID del texto seleccionado desde el atributo del popover
            const popoverEl = document.getElementById('popover-selection');
            const selectedId = popoverEl.getAttribute('data-selected-id');

            // Encontrar el elemento destacado por ID
            const highlightEl = document.getElementById(selectedId);

            if (highlightEl) {
                // Cambiar el color de fondo a amarillo
                highlightEl.style.backgroundColor = 'yellow';
                highlightEl.style.color = 'black'; // Asegurar que el texto sea legible sobre amarillo

                // Añadir una clase para identificación más fácil
                highlightEl.classList.add('reporting-highlight');
                highlights[selectedId] = highlightEl.innerText;
                console.log(highlights);
                $update();
                // Evitar que el highlight se limpie cuando se cierra el popover
                highlightEl.setAttribute('data-persistent', 'true');

                // Cerrar el popover
                popoverSelection.close();
            }
        }
        function showHighlights() {
            $update();

            if (!popupHighlights) {
                popupHighlights = $f7.popup.create({
                    el: $el.value.find('#popup-highlights')[0],
                    swipeToClose: false,
                    on: {
                        opened: function () {
                            app.on('sortableSort', function (listEl, data) {
                                console.log('sortableSort event fired', data);
                                    console.log('Our sortable moved!');
                                    updateHighlightsOrder();
                            });
                        }
                    }
                });
            }

            popupHighlights.open();
        }
        function updateHighlightsOrder() {
            console.log('updateHighlightsOrder called');

            const sortableEl = document.getElementById('sortable-highlights-list');
            const listItems = sortableEl.querySelectorAll('li[data-highlight-id]');

            console.log('Found list items with data-highlight-id:', listItems.length);

            // Crear nuevo objeto con el orden actual
            const newHighlights = {};

            listItems.forEach((item, index) => {
                const highlightId = item.getAttribute('data-highlight-id');
                console.log(`Item ${index}: id=${highlightId}`);

                if (highlightId && highlights[highlightId]) {
                    newHighlights[highlightId] = highlights[highlightId];
                }
            });

            // Reemplazar el objeto highlights
            highlights = newHighlights;

            console.log('Highlights reordered:', Object.keys(highlights));
            //$update();
        }
// Función auxiliar para eliminar highlight desde el popup
        function removeHighlightFromPopup(e, highlightId) {
            e.preventDefault();

            // Eliminar del objeto highlights
            delete highlights[highlightId];

            // Eliminar del DOM
            const highlightEl = document.getElementById(highlightId);
            if (highlightEl) {
                const parent = highlightEl.parentNode;
                parent.insertBefore(document.createTextNode(highlightEl.textContent), highlightEl);
                parent.removeChild(highlightEl);
            }

            // Actualizar la vista principal y el popup
            $update();

            // Si no quedan highlights, mostrar mensaje vacío
            if (Object.keys(highlights).length === 0) {
                // El template ya maneja el estado vacío automáticamente
            }
        }

// Función para toggle del sortable
        function toggleSortableDisable() {
            const sortableEl = document.getElementById('sortable-highlights-list');
            console.log('Toggle - element found:', sortableEl);

            if (sortableEl) {
                $f7.sortable.toggle(sortableEl);
                console.log('Sortable toggled');
            } else {
                console.log('Sortable element not found for toggle');
            }
        }

// Función para la acción general - AQUÍ PONES TU CALLBACK
        let generalAction = function() {
            console.log('Acción general ejecutada con todos los highlights:', highlights);


            // Aquí puedes hacer lo que quieras con todos los highlights:
            // - Exportar todos
            // - Enviar a API
            // - Generar reporte
            // - etc.
            const highlightTexts = Object.values(highlights);
            let myText =  "Please create a technical report using only the following information: '" +highlightTexts.join('\n') + "'";
            isResponseInBackground = true;
            setPrompt(myText);

            setTimeout(function(){
                isResponseInBackground = false;
            },1000)

           /* app.toast.create({
                text: `Processing  ${Object.keys(highlights).length} highlights...`,
                position: 'center',
                closeTimeout: 2000,
            }).open();*/
        }

        let initializeActionsCustomLayout = function () {
            actionsCustomLayout = $f7.actions.create({
                el: $el.value.find('#actions-custom-layout'),
                closeByBackdropClick: false,
                closeByOutsideClick: false,
                closeOnEscape: false
            });
        }

        // Función para manejar el clic en el botón de subir documento
        function handleFileUploadClick() {
            const fileInput = document.getElementById('document-upload');
            fileInput.click();
        }

// Añadir event listener al input de archivo
        function setupDocumentUpload() {
            const fileInput = document.getElementById('document-upload');

            fileInput.addEventListener('change', function (e) {
                if (e.target.files && e.target.files.length > 0) {
                    // Si tienes FileDropzone inicializado, puedes usarlo para procesar los archivos
                    if (window.myFileDropzone) {
                        window.myFileDropzone.handleFiles(e.target.files);
                    } else {
                        // Alternativa si no tienes FileDropzone
                        Array.from(e.target.files).forEach(file => {
                            console.log("Archivo seleccionado:", file.name);
                            // Aquí puedes implementar tu propia lógica de procesamiento
                        });
                    }
                }
            });
        }


        $on('pageBeforeIn', function () {

            scrollToBottomBtn = document.getElementById('scrollToBottom');
            pageContent = document.getElementById('conversationPage');

            initializeDialogChoiceChip();

            initializePopupTicket();

            initializeActionsCustomLayout();
            initializeFormValidator();
            initPopoverSelection();
        });
        $on('pageAfterIn', function () {
            const hasAcceptedTerms = localStorage.getItem('terms_accepted');

            if (!hasAcceptedTerms) {
                // Redirigir a la página de términos si no ha aceptado
                $f7.views.main.router.navigate('/screens/terms/', {
                    reloadCurrent: true,
                    clearPreviousHistory: true
                });
                return; // Detener ejecución adicional
            }
            loadAssistants().then(myAssistant => {
                console.log("Asistente cargado:", myAssistant);
                if (myAssistant) {
                    initAssistantMentions();
                    window.myFileDropzone = new FileDropzone({
                        dropzoneId: 'file-dropzone',
                        fileInputId: 'file-upload',
                        textareaId: 'prompt',
                        useSimbaDocumentTags: true,
                        framework7: $f7,  // Pasar la instancia de Framework7
                        onFileAdded: function (file) {
                            console.log("Archivo añadido:", file.name);
                        },
                        onFileRemoved: function (file) {
                            console.log("Archivo eliminado:", file.name);
                        },
                        onTextExtracted: function (file, text) {
                            console.log("Texto extraído de", file.name, ":", text.substring(0, 100) + "...");
                        },
                        onStaskExecuted: function (file, text) {
                            console.log(file)
                            const stask = {
                                file: file,
                                procedure: text
                            }
                            localStorage.setItem('stask', JSON.stringify(stask));
                            app.popup.create({
                                content: `
                <div class="popup popup-tablet-fullscreen">
                    <div class="view">
                        <div class="page">
                            <div class="navbar">
                                <div class="navbar-bg"></div>
                                <div class="navbar-inner">
                                    <div class="title">${text.procedure.name}</div>
                                    <div class="right">
                                        <a href="#" class="link popup-close"><i class="fa fa-close"></i></a>
                                    </div>
                                </div>
                            </div>
                            <div class="page-content hide-navbar-on-scroll">
                                <iframe src="https://assistant.simeng.es/#!/screens/walkthrough/"
                                    style="width:100%; height:100%; border:none;"
                                    frameborder="0"></iframe>
                            </div>
                        </div>
                    </div>
                </div>
            `,
                                // animate: true,
                                // swipeToClose: true,
                                // backdrop: true,
                                on: {
                                    opened: function () {
                                        console.log('Popup abierto');
                                    }
                                }
                            }).open();
                            console.log(stask);
                        },
                        onAllFilesProcessed: function (files) {
                            console.log("Todos los archivos han sido procesados:", files.length);
                            if (files.some(f => f.extractedText)) {
                                let extractedContent = window.myFileDropzone.getCombinedExtractedText("\n\n");
                                console.log(extractedContent)
                            }
                        }
                    });
                    // createConversation(myAssistant.guid);
                    scrollToBottomBtn = document.getElementById('scrollToBottom');
                    pageContent.addEventListener('scroll', checkScrollPosition);
                    checkScrollPosition();

                    $update();
                } else {

                    $f7.toast.show({
                        text: 'No assistant is available',
                        cssClass: 'color-red'
                    });
                }
                // Hacer algo con assistant
            }).catch(error => {
                console.error("Error al cargar asistentes:", error);
            });

            initializeMessagebar();
            initializeMessages();
            setupDocumentUpload();
            initAssistantMentions();
            initializePopupConfig(); // Add this line
            initializePopoverText()
            initializeConfigFormValidator(); // Add this line

// Evento para manejar el desplazamiento dentro de .page-content


        })
        return $render;
    }
</script>

